   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 101:stk500boot.c  **** #define	_FIX_ISSUE_181_
 102:stk500boot.c  **** 
 103:stk500boot.c  **** #include	<inttypes.h>
 104:stk500boot.c  **** #include	<avr/io.h>
 105:stk500boot.c  **** #include	<avr/interrupt.h>
 106:stk500boot.c  **** #include	<avr/boot.h>
 107:stk500boot.c  **** #include	<avr/pgmspace.h>
 108:stk500boot.c  **** #include	<util/delay.h>
 109:stk500boot.c  **** #include	<avr/eeprom.h>
 110:stk500boot.c  **** #include	<avr/common.h>
 111:stk500boot.c  **** #include	<stdlib.h>
 112:stk500boot.c  **** #include	"command.h"
 113:stk500boot.c  **** 
 114:stk500boot.c  **** 
 115:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 116:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 117:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 118:stk500boot.c  **** 	#define		ENABLE_MONITOR
 119:stk500boot.c  **** 	static void	RunMonitor(void);
 120:stk500boot.c  **** #endif
 121:stk500boot.c  **** 
 122:stk500boot.c  **** #ifndef EEWE
 123:stk500boot.c  **** 	#define EEWE    1
 124:stk500boot.c  **** #endif
 125:stk500boot.c  **** #ifndef EEMWE
 126:stk500boot.c  **** 	#define EEMWE   2
 127:stk500boot.c  **** #endif
 128:stk500boot.c  **** 
 129:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 130:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 131:stk500boot.c  **** 
 132:stk500boot.c  **** 
 133:stk500boot.c  **** /*
 134:stk500boot.c  ****  * Uncomment the following lines to save code space
 135:stk500boot.c  ****  */
 136:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 137:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 138:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 139:stk500boot.c  **** //
 140:stk500boot.c  **** 
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** //************************************************************************
 144:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 145:stk500boot.c  **** //*	indicates that bootloader is active
 146:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 147:stk500boot.c  **** //************************************************************************
 148:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 149:stk500boot.c  **** 
 150:stk500boot.c  **** #ifdef _MEGA_BOARD_
 151:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 152:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 153:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 154:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 155:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 156:stk500boot.c  **** 	//*	onbarod led is PORTE4
 157:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 158:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 159:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 160:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 161:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 162:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 163:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 164:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 165:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 166:stk500boot.c  **** #elif defined( _PENGUINO_ )
 167:stk500boot.c  **** 	//*	this is for the Penguino
 168:stk500boot.c  **** 	//*	onbarod led is PORTE4
 169:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 170:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 171:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 172:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 173:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 174:stk500boot.c  **** 	//*	onbarod led is PORTE4
 175:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 176:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 177:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 178:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 179:stk500boot.c  **** 	//*	onbarod led is PORTA7
 180:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 181:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 182:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 183:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 184:stk500boot.c  **** 
 185:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 186:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 187:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 188:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 189:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 190:stk500boot.c  **** 
 191:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 192:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 193:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 194:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 195:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 196:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 197:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 198:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 199:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 200:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 201:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 202:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 203:stk500boot.c  **** #elif defined( _AVRLIP_ )
 204:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 205:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 206:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 207:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 208:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 209:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 210:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 211:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 212:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 213:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 214:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 215:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 216:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 217:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 218:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 219:stk500boot.c  **** #else
 220:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 221:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 222:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 223:stk500boot.c  **** #endif
 224:stk500boot.c  **** 
 225:stk500boot.c  **** 
 226:stk500boot.c  **** 
 227:stk500boot.c  **** /*
 228:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 229:stk500boot.c  ****  */
 230:stk500boot.c  **** #ifndef F_CPU
 231:stk500boot.c  **** 	#define F_CPU 16000000UL
 232:stk500boot.c  **** #endif
 233:stk500boot.c  **** 
 234:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 235:stk500boot.c  **** /*
 236:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 237:stk500boot.c  ****  */
 238:stk500boot.c  **** 
 239:stk500boot.c  **** #ifndef BAUDRATE
 240:stk500boot.c  **** 	#define BAUDRATE 57600
 241:stk500boot.c  **** #endif
 242:stk500boot.c  **** 
 243:stk500boot.c  **** /*
 244:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 245:stk500boot.c  ****  */
 246:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 247:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 248:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 249:stk500boot.c  **** 	#else
 250:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 251:stk500boot.c  **** 	#endif
 252:stk500boot.c  **** #endif
 253:stk500boot.c  **** 
 254:stk500boot.c  **** /*
 255:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 256:stk500boot.c  ****  */
 257:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 258:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 259:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 260:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 261:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 262:stk500boot.c  **** 
 263:stk500boot.c  **** /*
 264:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 265:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 266:stk500boot.c  ****  */
 267:stk500boot.c  **** //#define BOOTSIZE 1024
 268:stk500boot.c  **** #if FLASHEND > 0x0F000
 269:stk500boot.c  **** 	#define BOOTSIZE 8192
 270:stk500boot.c  **** #else
 271:stk500boot.c  **** 	#define BOOTSIZE 2048
 272:stk500boot.c  **** #endif
 273:stk500boot.c  **** 
 274:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 275:stk500boot.c  **** 
 276:stk500boot.c  **** /*
 277:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 278:stk500boot.c  ****  */
 279:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 280:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 281:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 282:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 283:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 284:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 285:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 287:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 289:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 291:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 293:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 295:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 297:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 299:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 301:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 303:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 305:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 307:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 308:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 309:stk500boot.c  **** #else
 310:stk500boot.c  **** 	#error "no signature definition for MCU available"
 311:stk500boot.c  **** #endif
 312:stk500boot.c  **** 
 313:stk500boot.c  **** 
 314:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 315:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 316:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 317:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 318:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 319:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 320:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 321:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 322:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 323:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 324:stk500boot.c  **** 
 325:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 326:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 327:stk500boot.c  **** 	/* ATMega8 with one USART */
 328:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 329:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 330:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 331:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 332:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 333:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 334:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 335:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 336:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 337:stk500boot.c  **** 
 338:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 339:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 340:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 341:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 342:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 343:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 344:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 345:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 346:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 347:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 348:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 349:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 350:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 351:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 352:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 353:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 354:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 355:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 356:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 357:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 358:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 359:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 360:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 361:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 362:stk500boot.c  **** 	//* catch all
 363:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 364:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 365:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 366:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 367:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 368:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 369:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 370:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 371:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 372:stk500boot.c  **** #else
 373:stk500boot.c  **** 	#error "no UART definition for MCU available"
 374:stk500boot.c  **** #endif
 375:stk500boot.c  **** 
 376:stk500boot.c  **** 
 377:stk500boot.c  **** 
 378:stk500boot.c  **** /*
 379:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 380:stk500boot.c  ****  */
 381:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 382:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 383:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 384:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 385:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 386:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 387:stk500boot.c  **** #else
 388:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 389:stk500boot.c  **** #endif
 390:stk500boot.c  **** 
 391:stk500boot.c  **** 
 392:stk500boot.c  **** /*
 393:stk500boot.c  ****  * States used in the receive state machine
 394:stk500boot.c  ****  */
 395:stk500boot.c  **** #define	ST_START		0
 396:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 397:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 398:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 399:stk500boot.c  **** #define ST_GET_TOKEN	4
 400:stk500boot.c  **** #define ST_GET_DATA		5
 401:stk500boot.c  **** #define	ST_GET_CHECK	6
 402:stk500boot.c  **** #define	ST_PROCESS		7
 403:stk500boot.c  **** 
 404:stk500boot.c  **** /*
 405:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 406:stk500boot.c  ****  */
 407:stk500boot.c  **** #if defined(RAMPZ)
 408:stk500boot.c  **** 	typedef uint32_t address_t;
 409:stk500boot.c  **** #else
 410:stk500boot.c  **** 	typedef uint16_t address_t;
 411:stk500boot.c  **** #endif
 412:stk500boot.c  **** 
 413:stk500boot.c  **** /*
 414:stk500boot.c  ****  * function prototypes
 415:stk500boot.c  ****  */
 416:stk500boot.c  **** static void sendchar(char c);
 417:stk500boot.c  **** static unsigned char recchar(void);
 418:stk500boot.c  **** 
 419:stk500boot.c  **** /*
 420:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 421:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 422:stk500boot.c  ****  */
 423:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 424:stk500boot.c  **** #include <avr/sfr_defs.h>
 425:stk500boot.c  **** 
 426:stk500boot.c  **** //#define	SPH_REG	0x3E
 427:stk500boot.c  **** //#define	SPL_REG	0x3D
 428:stk500boot.c  **** 
 429:stk500boot.c  **** //*****************************************************************************
 430:stk500boot.c  **** void __jumpMain(void)
 431:stk500boot.c  **** {
 432:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 433:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 434:stk500boot.c  **** 
 435:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 436:stk500boot.c  **** 
 437:stk500boot.c  **** //*	set stack pointer to top of RAM
 438:stk500boot.c  **** 
 439:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 440:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 441:stk500boot.c  **** 
 442:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 443:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 444:stk500boot.c  **** 
 445:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 446:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 447:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 448:stk500boot.c  **** }
 449:stk500boot.c  **** 
 450:stk500boot.c  **** 
 451:stk500boot.c  **** //*****************************************************************************
 452:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 453:stk500boot.c  **** {
 454:stk500boot.c  **** 	unsigned int i;
 455:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 456:stk500boot.c  **** 	{
 457:stk500boot.c  **** 		_delay_ms(0.5);
 458:stk500boot.c  **** 	}
 459:stk500boot.c  **** }
 460:stk500boot.c  **** 
 461:stk500boot.c  **** 
 462:stk500boot.c  **** //*****************************************************************************
 463:stk500boot.c  **** /*
 464:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 465:stk500boot.c  ****  */
 466:stk500boot.c  **** static void sendchar(char c)
 467:stk500boot.c  **** {
  15               		.loc 1 467 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 468:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 468 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 469:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 469 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 470:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 470 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE13:
  39               		.section	.text.unlikely,"ax",@progbits
  41               	recchar:
  42               	.LFB15:
 471:stk500boot.c  **** }
 472:stk500boot.c  **** 
 473:stk500boot.c  **** 
 474:stk500boot.c  **** //************************************************************************
 475:stk500boot.c  **** static int	Serial_Available(void)
 476:stk500boot.c  **** {
 477:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 478:stk500boot.c  **** }
 479:stk500boot.c  **** 
 480:stk500boot.c  **** 
 481:stk500boot.c  **** //*****************************************************************************
 482:stk500boot.c  **** /*
 483:stk500boot.c  ****  * Read single byte from USART, block if no data available
 484:stk500boot.c  ****  */
 485:stk500boot.c  **** static unsigned char recchar(void)
 486:stk500boot.c  **** {
  43               		.loc 1 486 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49               	.L7:
 487:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  50               		.loc 1 487 0 discriminator 1
  51 0000 8091 C000 		lds r24,192
  52 0004 87FF      		sbrs r24,7
  53 0006 00C0      		rjmp .L7
 488:stk500boot.c  **** 	{
 489:stk500boot.c  **** 		// wait for data
 490:stk500boot.c  **** 	}
 491:stk500boot.c  **** 	return UART_DATA_REG;
  54               		.loc 1 491 0
  55 0008 8091 C600 		lds r24,198
 492:stk500boot.c  **** }
  56               		.loc 1 492 0
  57 000c 0895      		ret
  58               		.cfi_endproc
  59               	.LFE15:
  61               		.section	.init9,"ax",@progbits
  62               	.global	__jumpMain
  64               	__jumpMain:
  65               	.LFB11:
 431:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  66               		.loc 1 431 0
  67               		.cfi_startproc
  68               	/* prologue: naked */
  69               	/* frame size = 0 */
  70               	/* stack size = 0 */
  71               	.L__stack_usage = 0
 435:stk500boot.c  **** 
  72               		.loc 1 435 0
  73               	/* #APP */
  74               	 ;  435 "stk500boot.c" 1
  75               		.set __stack, 8703
  76               	 ;  0 "" 2
 439:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  77               		.loc 1 439 0
  78               	 ;  439 "stk500boot.c" 1
  79 0000 01E2      		ldi	16, 33
  80               	 ;  0 "" 2
 440:stk500boot.c  **** 
  81               		.loc 1 440 0
  82               	 ;  440 "stk500boot.c" 1
  83 0002 0EBF      		out 62,16
  84               	 ;  0 "" 2
 442:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  85               		.loc 1 442 0
  86               	 ;  442 "stk500boot.c" 1
  87 0004 0FEF      		ldi	16, 255
  88               	 ;  0 "" 2
 443:stk500boot.c  **** 
  89               		.loc 1 443 0
  90               	 ;  443 "stk500boot.c" 1
  91 0006 0DBF      		out 61,16
  92               	 ;  0 "" 2
 445:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  93               		.loc 1 445 0
  94               	 ;  445 "stk500boot.c" 1
  95 0008 1124      		clr __zero_reg__
  96               	 ;  0 "" 2
 446:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
  97               		.loc 1 446 0
  98               	 ;  446 "stk500boot.c" 1
  99 000a 1FBE      		out 63, __zero_reg__
 100               	 ;  0 "" 2
 447:stk500boot.c  **** }
 101               		.loc 1 447 0
 102               	 ;  447 "stk500boot.c" 1
 103 000c 0C94 0000 		jmp main
 104               	 ;  0 "" 2
 105               	/* epilogue start */
 448:stk500boot.c  **** 
 106               		.loc 1 448 0
 107               	/* #NOAPP */
 108               		.cfi_endproc
 109               	.LFE11:
 111               		.text
 112               	.global	delay_ms
 114               	delay_ms:
 115               	.LFB12:
 453:stk500boot.c  **** 	unsigned int i;
 116               		.loc 1 453 0
 117               		.cfi_startproc
 118               	.LVL3:
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 455:stk500boot.c  **** 	{
 123               		.loc 1 455 0
 124 0018 20E0      		ldi r18,0
 125 001a 30E0      		ldi r19,0
 126               	.LVL4:
 127               	.L11:
 455:stk500boot.c  **** 	{
 128               		.loc 1 455 0 is_stmt 0 discriminator 1
 129 001c 2817      		cp r18,r24
 130 001e 3907      		cpc r19,r25
 131 0020 01F0      		breq .L13
 132               	.LVL5:
 133               	.LBB51:
 134               	.LBB52:
 135               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 136               		.loc 2 163 0 is_stmt 1
 137 0022 EFEC      		ldi r30,lo8(1999)
 138 0024 F7E0      		ldi r31,hi8(1999)
 139 0026 3197      	1:	sbiw r30,1
 140 0028 01F4      		brne 1b
 141 002a 00C0      		rjmp .
 142 002c 0000      		nop
 143               	.LBE52:
 144               	.LBE51:
 455:stk500boot.c  **** 	{
 145               		.loc 1 455 0
 146 002e 2F5F      		subi r18,-1
 147 0030 3F4F      		sbci r19,-1
 148               	.LVL6:
 149 0032 00C0      		rjmp .L11
 150               	.LVL7:
 151               	.L13:
 152               	/* epilogue start */
 459:stk500boot.c  **** 
 153               		.loc 1 459 0
 154 0034 0895      		ret
 155               		.cfi_endproc
 156               	.LFE12:
 158               	.global	PrintFromPROGMEM
 160               	PrintFromPROGMEM:
 161               	.LFB18:
 493:stk500boot.c  **** 
 494:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 495:stk500boot.c  **** //*****************************************************************************
 496:stk500boot.c  **** static unsigned char recchar_timeout(void)
 497:stk500boot.c  **** {
 498:stk500boot.c  **** uint32_t count = 0;
 499:stk500boot.c  **** 
 500:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 501:stk500boot.c  **** 	{
 502:stk500boot.c  **** 		// wait for data
 503:stk500boot.c  **** 		count++;
 504:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 505:stk500boot.c  **** 		{
 506:stk500boot.c  **** 		unsigned int	data;
 507:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 508:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 509:stk500boot.c  **** 		#else
 510:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 511:stk500boot.c  **** 		#endif
 512:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 513:stk500boot.c  **** 			{
 514:stk500boot.c  **** 				asm volatile(
 515:stk500boot.c  **** 						"clr	r30		\n\t"
 516:stk500boot.c  **** 						"clr	r31		\n\t"
 517:stk500boot.c  **** 						"ijmp	\n\t"
 518:stk500boot.c  **** 						);
 519:stk500boot.c  **** 			}
 520:stk500boot.c  **** 			count	=	0;
 521:stk500boot.c  **** 		}
 522:stk500boot.c  **** 	}
 523:stk500boot.c  **** 	return UART_DATA_REG;
 524:stk500boot.c  **** }
 525:stk500boot.c  **** 
 526:stk500boot.c  **** //*	for watch dog timer startup
 527:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 528:stk500boot.c  **** 
 529:stk500boot.c  **** 
 530:stk500boot.c  **** //*****************************************************************************
 531:stk500boot.c  **** int main(void)
 532:stk500boot.c  **** {
 533:stk500boot.c  **** 	address_t		address			=	0;
 534:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 535:stk500boot.c  **** 	unsigned char	msgParseState;
 536:stk500boot.c  **** 	unsigned int	ii				=	0;
 537:stk500boot.c  **** 	unsigned char	checksum		=	0;
 538:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 539:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 540:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 541:stk500boot.c  **** 	unsigned char	c, *p;
 542:stk500boot.c  **** 	unsigned char   isLeave = 0;
 543:stk500boot.c  **** 
 544:stk500boot.c  **** 	unsigned long	boot_timeout;
 545:stk500boot.c  **** 	unsigned long	boot_timer;
 546:stk500boot.c  **** 	unsigned int	boot_state;
 547:stk500boot.c  **** #ifdef ENABLE_MONITOR
 548:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 549:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 550:stk500boot.c  **** #endif
 551:stk500boot.c  **** 
 552:stk500boot.c  **** 	//*	some chips dont set the stack properly
 553:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 554:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 555:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 556:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 557:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 558:stk500boot.c  **** 
 559:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 560:stk500boot.c  **** 	//************************************************************************
 561:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 562:stk500boot.c  **** 	//*	handle the watch dog timer
 563:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 564:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 565:stk500boot.c  **** 
 566:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 567:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 568:stk500boot.c  **** 	MCUSR	=	0;
 569:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 570:stk500boot.c  **** 	WDTCSR	=	0;
 571:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 572:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 573:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 574:stk500boot.c  **** 	{
 575:stk500boot.c  **** 		app_start();
 576:stk500boot.c  **** 	}
 577:stk500boot.c  **** 	//************************************************************************
 578:stk500boot.c  **** #endif
 579:stk500boot.c  **** 
 580:stk500boot.c  **** 
 581:stk500boot.c  **** 	boot_timer	=	0;
 582:stk500boot.c  **** 	boot_state	=	0;
 583:stk500boot.c  **** 
 584:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 585:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 586:stk500boot.c  **** //	boot_timeout	=	170000;
 587:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 588:stk500boot.c  **** #else
 589:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 590:stk500boot.c  **** #endif
 591:stk500boot.c  **** 	/*
 592:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 593:stk500boot.c  **** 	 */
 594:stk500boot.c  **** 
 595:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 596:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 597:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 598:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 599:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 600:stk500boot.c  **** 
 601:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 602:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 603:stk500boot.c  **** 	{
 604:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 605:stk500boot.c  **** 		delay_ms(100);
 606:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 607:stk500boot.c  **** 		delay_ms(100);
 608:stk500boot.c  **** 	}
 609:stk500boot.c  **** #endif
 610:stk500boot.c  **** 
 611:stk500boot.c  **** #endif
 612:stk500boot.c  **** 	/*
 613:stk500boot.c  **** 	 * Init UART
 614:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 615:stk500boot.c  **** 	 */
 616:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 617:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 618:stk500boot.c  **** #endif
 619:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 620:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 621:stk500boot.c  **** 
 622:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 623:stk500boot.c  **** 
 624:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 625:stk500boot.c  **** //	delay_ms(500);
 626:stk500boot.c  **** 
 627:stk500boot.c  **** 	sendchar('s');
 628:stk500boot.c  **** 	sendchar('t');
 629:stk500boot.c  **** 	sendchar('k');
 630:stk500boot.c  **** //	sendchar('5');
 631:stk500boot.c  **** //	sendchar('0');
 632:stk500boot.c  **** //	sendchar('0');
 633:stk500boot.c  **** 	sendchar('v');
 634:stk500boot.c  **** 	sendchar('2');
 635:stk500boot.c  **** 	sendchar(0x0d);
 636:stk500boot.c  **** 	sendchar(0x0a);
 637:stk500boot.c  **** 
 638:stk500boot.c  **** 	delay_ms(100);
 639:stk500boot.c  **** #endif
 640:stk500boot.c  **** 
 641:stk500boot.c  **** 	while (boot_state==0)
 642:stk500boot.c  **** 	{
 643:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 644:stk500boot.c  **** 		{
 645:stk500boot.c  **** 			_delay_ms(0.001);
 646:stk500boot.c  **** 			boot_timer++;
 647:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 648:stk500boot.c  **** 			{
 649:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 650:stk500boot.c  **** 			}
 651:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 652:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 653:stk500boot.c  **** 			{
 654:stk500boot.c  **** 				//*	toggle the LED
 655:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 656:stk500boot.c  **** 			}
 657:stk500boot.c  **** 		#endif
 658:stk500boot.c  **** 		}
 659:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 660:stk500boot.c  **** 	}
 661:stk500boot.c  **** 
 662:stk500boot.c  **** 
 663:stk500boot.c  **** 	if (boot_state==1)
 664:stk500boot.c  **** 	{
 665:stk500boot.c  **** 		//*	main loop
 666:stk500boot.c  **** 		while (!isLeave)
 667:stk500boot.c  **** 		{
 668:stk500boot.c  **** 			/*
 669:stk500boot.c  **** 			 * Collect received bytes to a complete message
 670:stk500boot.c  **** 			 */
 671:stk500boot.c  **** 			msgParseState	=	ST_START;
 672:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 673:stk500boot.c  **** 			{
 674:stk500boot.c  **** 				if (boot_state==1)
 675:stk500boot.c  **** 				{
 676:stk500boot.c  **** 					boot_state	=	0;
 677:stk500boot.c  **** 					c			=	UART_DATA_REG;
 678:stk500boot.c  **** 				}
 679:stk500boot.c  **** 				else
 680:stk500boot.c  **** 				{
 681:stk500boot.c  **** 				//	c	=	recchar();
 682:stk500boot.c  **** 					c	=	recchar_timeout();
 683:stk500boot.c  **** 					
 684:stk500boot.c  **** 				}
 685:stk500boot.c  **** 
 686:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 687:stk500boot.c  **** 				rcvdCharCntr++;
 688:stk500boot.c  **** 
 689:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 690:stk500boot.c  **** 				{
 691:stk500boot.c  **** 					exPointCntr++;
 692:stk500boot.c  **** 					if (exPointCntr == 3)
 693:stk500boot.c  **** 					{
 694:stk500boot.c  **** 						RunMonitor();
 695:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 696:stk500boot.c  **** 						isLeave			=	1;
 697:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 698:stk500boot.c  **** 						break;
 699:stk500boot.c  **** 					}
 700:stk500boot.c  **** 				}
 701:stk500boot.c  **** 				else
 702:stk500boot.c  **** 				{
 703:stk500boot.c  **** 					exPointCntr	=	0;
 704:stk500boot.c  **** 				}
 705:stk500boot.c  **** 			#endif
 706:stk500boot.c  **** 
 707:stk500boot.c  **** 				switch (msgParseState)
 708:stk500boot.c  **** 				{
 709:stk500boot.c  **** 					case ST_START:
 710:stk500boot.c  **** 						if ( c == MESSAGE_START )
 711:stk500boot.c  **** 						{
 712:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 713:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 714:stk500boot.c  **** 						}
 715:stk500boot.c  **** 						break;
 716:stk500boot.c  **** 
 717:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 718:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 719:stk500boot.c  **** 						seqNum			=	c;
 720:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 721:stk500boot.c  **** 						checksum		^=	c;
 722:stk500boot.c  **** 					#else
 723:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 724:stk500boot.c  **** 						{
 725:stk500boot.c  **** 							seqNum			=	c;
 726:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 727:stk500boot.c  **** 							checksum		^=	c;
 728:stk500boot.c  **** 						}
 729:stk500boot.c  **** 						else
 730:stk500boot.c  **** 						{
 731:stk500boot.c  **** 							msgParseState	=	ST_START;
 732:stk500boot.c  **** 						}
 733:stk500boot.c  **** 					#endif
 734:stk500boot.c  **** 						break;
 735:stk500boot.c  **** 
 736:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 737:stk500boot.c  **** 						msgLength		=	c<<8;
 738:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 739:stk500boot.c  **** 						checksum		^=	c;
 740:stk500boot.c  **** 						break;
 741:stk500boot.c  **** 
 742:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 743:stk500boot.c  **** 						msgLength		|=	c;
 744:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 745:stk500boot.c  **** 						checksum		^=	c;
 746:stk500boot.c  **** 						break;
 747:stk500boot.c  **** 
 748:stk500boot.c  **** 					case ST_GET_TOKEN:
 749:stk500boot.c  **** 						if ( c == TOKEN )
 750:stk500boot.c  **** 						{
 751:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 752:stk500boot.c  **** 							checksum		^=	c;
 753:stk500boot.c  **** 							ii				=	0;
 754:stk500boot.c  **** 						}
 755:stk500boot.c  **** 						else
 756:stk500boot.c  **** 						{
 757:stk500boot.c  **** 							msgParseState	=	ST_START;
 758:stk500boot.c  **** 						}
 759:stk500boot.c  **** 						break;
 760:stk500boot.c  **** 
 761:stk500boot.c  **** 					case ST_GET_DATA:
 762:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 763:stk500boot.c  **** 						checksum		^=	c;
 764:stk500boot.c  **** 						if (ii == msgLength )
 765:stk500boot.c  **** 						{
 766:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 767:stk500boot.c  **** 						}
 768:stk500boot.c  **** 						break;
 769:stk500boot.c  **** 
 770:stk500boot.c  **** 					case ST_GET_CHECK:
 771:stk500boot.c  **** 						if ( c == checksum )
 772:stk500boot.c  **** 						{
 773:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 774:stk500boot.c  **** 						}
 775:stk500boot.c  **** 						else
 776:stk500boot.c  **** 						{
 777:stk500boot.c  **** 							msgParseState	=	ST_START;
 778:stk500boot.c  **** 						}
 779:stk500boot.c  **** 						break;
 780:stk500boot.c  **** 				}	//	switch
 781:stk500boot.c  **** 			}	//	while(msgParseState)
 782:stk500boot.c  **** 
 783:stk500boot.c  **** 			/*
 784:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 785:stk500boot.c  **** 			 */
 786:stk500boot.c  **** 
 787:stk500boot.c  **** 			switch (msgBuffer[0])
 788:stk500boot.c  **** 			{
 789:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 790:stk500boot.c  **** 				case CMD_SPI_MULTI:
 791:stk500boot.c  **** 					{
 792:stk500boot.c  **** 						unsigned char answerByte;
 793:stk500boot.c  **** 						unsigned char flag=0;
 794:stk500boot.c  **** 
 795:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 796:stk500boot.c  **** 						{
 797:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 798:stk500boot.c  **** 
 799:stk500boot.c  **** 							if ( signatureIndex == 0 )
 800:stk500boot.c  **** 							{
 801:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 802:stk500boot.c  **** 							}
 803:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 804:stk500boot.c  **** 							{
 805:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 806:stk500boot.c  **** 							}
 807:stk500boot.c  **** 							else
 808:stk500boot.c  **** 							{
 809:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 810:stk500boot.c  **** 							}
 811:stk500boot.c  **** 						}
 812:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 813:stk500boot.c  **** 						{
 814:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 815:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 816:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 817:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 818:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 819:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 820:stk500boot.c  **** 							{
 821:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 822:stk500boot.c  **** 							}
 823:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 824:stk500boot.c  **** 							{
 825:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 826:stk500boot.c  **** 							}
 827:stk500boot.c  **** 							else
 828:stk500boot.c  **** 							{
 829:stk500boot.c  **** 								answerByte	=	0;
 830:stk500boot.c  **** 							}
 831:stk500boot.c  **** 						}
 832:stk500boot.c  **** 						else
 833:stk500boot.c  **** 						{
 834:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 835:stk500boot.c  **** 						}
 836:stk500boot.c  **** 						if ( !flag )
 837:stk500boot.c  **** 						{
 838:stk500boot.c  **** 							msgLength		=	7;
 839:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 840:stk500boot.c  **** 							msgBuffer[2]	=	0;
 841:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 842:stk500boot.c  **** 							msgBuffer[4]	=	0;
 843:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 844:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 845:stk500boot.c  **** 						}
 846:stk500boot.c  **** 					}
 847:stk500boot.c  **** 					break;
 848:stk500boot.c  **** 	#endif
 849:stk500boot.c  **** 				case CMD_SIGN_ON:
 850:stk500boot.c  **** 					msgLength		=	11;
 851:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 852:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 853:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 854:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 855:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 856:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 857:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 858:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 859:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 860:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 861:stk500boot.c  **** 					break;
 862:stk500boot.c  **** 
 863:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 864:stk500boot.c  **** 					{
 865:stk500boot.c  **** 						unsigned char value;
 866:stk500boot.c  **** 
 867:stk500boot.c  **** 						switch(msgBuffer[1])
 868:stk500boot.c  **** 						{
 869:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 870:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 871:stk500boot.c  **** 							break;
 872:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 873:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 874:stk500boot.c  **** 							break;
 875:stk500boot.c  **** 						case PARAM_HW_VER:
 876:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 877:stk500boot.c  **** 							break;
 878:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 879:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 880:stk500boot.c  **** 							break;
 881:stk500boot.c  **** 						case PARAM_SW_MINOR:
 882:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 883:stk500boot.c  **** 							break;
 884:stk500boot.c  **** 						default:
 885:stk500boot.c  **** 							value	=	0;
 886:stk500boot.c  **** 							break;
 887:stk500boot.c  **** 						}
 888:stk500boot.c  **** 						msgLength		=	3;
 889:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 890:stk500boot.c  **** 						msgBuffer[2]	=	value;
 891:stk500boot.c  **** 					}
 892:stk500boot.c  **** 					break;
 893:stk500boot.c  **** 
 894:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 895:stk500boot.c  **** 					isLeave	=	1;
 896:stk500boot.c  **** 					//*	fall thru
 897:stk500boot.c  **** 
 898:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 899:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 900:stk500boot.c  **** 					msgLength		=	2;
 901:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 902:stk500boot.c  **** 					break;
 903:stk500boot.c  **** 
 904:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 905:stk500boot.c  **** 					{
 906:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 907:stk500boot.c  **** 						unsigned char signature;
 908:stk500boot.c  **** 
 909:stk500boot.c  **** 						if ( signatureIndex == 0 )
 910:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 911:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 912:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 913:stk500boot.c  **** 						else
 914:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 915:stk500boot.c  **** 
 916:stk500boot.c  **** 						msgLength		=	4;
 917:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 918:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 919:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 920:stk500boot.c  **** 					}
 921:stk500boot.c  **** 					break;
 922:stk500boot.c  **** 
 923:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 924:stk500boot.c  **** 					msgLength		=	4;
 925:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 926:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 927:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 928:stk500boot.c  **** 					break;
 929:stk500boot.c  **** 
 930:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 931:stk500boot.c  **** 					{
 932:stk500boot.c  **** 						unsigned char fuseBits;
 933:stk500boot.c  **** 
 934:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 935:stk500boot.c  **** 						{
 936:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 937:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 938:stk500boot.c  **** 							else
 939:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 940:stk500boot.c  **** 						}
 941:stk500boot.c  **** 						else
 942:stk500boot.c  **** 						{
 943:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 944:stk500boot.c  **** 						}
 945:stk500boot.c  **** 						msgLength		=	4;
 946:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 947:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 948:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 949:stk500boot.c  **** 					}
 950:stk500boot.c  **** 					break;
 951:stk500boot.c  **** 
 952:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 953:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 954:stk500boot.c  **** 					{
 955:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 956:stk500boot.c  **** 
 957:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 958:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 959:stk500boot.c  **** 						boot_spm_busy_wait();
 960:stk500boot.c  **** 
 961:stk500boot.c  **** 						msgLength		=	3;
 962:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 963:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 964:stk500boot.c  **** 					}
 965:stk500boot.c  **** 					break;
 966:stk500boot.c  **** 	#endif
 967:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 968:stk500boot.c  **** 					eraseAddress	=	0;
 969:stk500boot.c  **** 					msgLength		=	2;
 970:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 971:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 972:stk500boot.c  **** 					break;
 973:stk500boot.c  **** 
 974:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 975:stk500boot.c  **** 	#if defined(RAMPZ)
 976:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 977:stk500boot.c  **** 	#else
 978:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 979:stk500boot.c  **** 	#endif
 980:stk500boot.c  **** 					msgLength		=	2;
 981:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 982:stk500boot.c  **** 					break;
 983:stk500boot.c  **** 
 984:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
 985:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
 986:stk500boot.c  **** 					{
 987:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 988:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 989:stk500boot.c  **** 						unsigned int	data;
 990:stk500boot.c  **** 						unsigned char	highByte, lowByte;
 991:stk500boot.c  **** 						address_t		tempaddress	=	address;
 992:stk500boot.c  **** 
 993:stk500boot.c  **** 
 994:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 995:stk500boot.c  **** 						{
 996:stk500boot.c  **** 							// erase only main section (bootloader protection)
 997:stk500boot.c  **** 							if (eraseAddress < APP_END )
 998:stk500boot.c  **** 							{
 999:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1000:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1001:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1002:stk500boot.c  **** 							}
1003:stk500boot.c  **** 
1004:stk500boot.c  **** 							/* Write FLASH */
1005:stk500boot.c  **** 							do {
1006:stk500boot.c  **** 								lowByte		=	*p++;
1007:stk500boot.c  **** 								highByte 	=	*p++;
1008:stk500boot.c  **** 
1009:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1010:stk500boot.c  **** 								boot_page_fill(address,data);
1011:stk500boot.c  **** 
1012:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1013:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1014:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1015:stk500boot.c  **** 
1016:stk500boot.c  **** 							boot_page_write(tempaddress);
1017:stk500boot.c  **** 							boot_spm_busy_wait();
1018:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1019:stk500boot.c  **** 						}
1020:stk500boot.c  **** 						else
1021:stk500boot.c  **** 						{
1022:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1023:stk500boot.c  **** 							uint16_t ii = address >> 1;
1024:stk500boot.c  **** 							/* write EEPROM */
1025:stk500boot.c  **** 							while (size) {
1026:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1027:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1028:stk500boot.c  **** 								ii++;
1029:stk500boot.c  **** 								size--;
1030:stk500boot.c  **** 							}
1031:stk500boot.c  **** 						}
1032:stk500boot.c  **** 						msgLength		=	2;
1033:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1034:stk500boot.c  **** 					}
1035:stk500boot.c  **** 					break;
1036:stk500boot.c  **** 
1037:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1038:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1039:stk500boot.c  **** 					{
1040:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1041:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1042:stk500boot.c  **** 						msgLength				=	size+3;
1043:stk500boot.c  **** 
1044:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1045:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1046:stk500boot.c  **** 						{
1047:stk500boot.c  **** 							unsigned int data;
1048:stk500boot.c  **** 
1049:stk500boot.c  **** 							// Read FLASH
1050:stk500boot.c  **** 							do {
1051:stk500boot.c  **** 						//#if defined(RAMPZ)
1052:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1053:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1054:stk500boot.c  **** 						#else
1055:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1056:stk500boot.c  **** 						#endif
1057:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1058:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1059:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1060:stk500boot.c  **** 								size	-=	2;
1061:stk500boot.c  **** 							}while (size);
1062:stk500boot.c  **** 						}
1063:stk500boot.c  **** 						else
1064:stk500boot.c  **** 						{
1065:stk500boot.c  **** 							/* Read EEPROM */
1066:stk500boot.c  **** 							do {
1067:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1068:stk500boot.c  **** 								EEARH	=	((address >> 8));
1069:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1070:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1071:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1072:stk500boot.c  **** 								size--;
1073:stk500boot.c  **** 							} while (size);
1074:stk500boot.c  **** 						}
1075:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1076:stk500boot.c  **** 					}
1077:stk500boot.c  **** 					break;
1078:stk500boot.c  **** 
1079:stk500boot.c  **** 				default:
1080:stk500boot.c  **** 					msgLength		=	2;
1081:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1082:stk500boot.c  **** 					break;
1083:stk500boot.c  **** 			}
1084:stk500boot.c  **** 
1085:stk500boot.c  **** 			/*
1086:stk500boot.c  **** 			 * Now send answer message back
1087:stk500boot.c  **** 			 */
1088:stk500boot.c  **** 			sendchar(MESSAGE_START);
1089:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1090:stk500boot.c  **** 
1091:stk500boot.c  **** 			sendchar(seqNum);
1092:stk500boot.c  **** 			checksum	^=	seqNum;
1093:stk500boot.c  **** 
1094:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1095:stk500boot.c  **** 			sendchar(c);
1096:stk500boot.c  **** 			checksum	^=	c;
1097:stk500boot.c  **** 
1098:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1099:stk500boot.c  **** 			sendchar(c);
1100:stk500boot.c  **** 			checksum ^= c;
1101:stk500boot.c  **** 
1102:stk500boot.c  **** 			sendchar(TOKEN);
1103:stk500boot.c  **** 			checksum ^= TOKEN;
1104:stk500boot.c  **** 
1105:stk500boot.c  **** 			p	=	msgBuffer;
1106:stk500boot.c  **** 			while ( msgLength )
1107:stk500boot.c  **** 			{
1108:stk500boot.c  **** 				c	=	*p++;
1109:stk500boot.c  **** 				sendchar(c);
1110:stk500boot.c  **** 				checksum ^=c;
1111:stk500boot.c  **** 				msgLength--;
1112:stk500boot.c  **** 			}
1113:stk500boot.c  **** 			sendchar(checksum);
1114:stk500boot.c  **** 			seqNum++;
1115:stk500boot.c  **** 	
1116:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1117:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1118:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1119:stk500boot.c  **** 		#endif
1120:stk500boot.c  **** 
1121:stk500boot.c  **** 		}
1122:stk500boot.c  **** 	}
1123:stk500boot.c  **** 
1124:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1125:stk500boot.c  **** 	//*	this is for debugging it can be removed
1126:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1127:stk500boot.c  **** 	{
1128:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1129:stk500boot.c  **** 		delay_ms(200);
1130:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1131:stk500boot.c  **** 		delay_ms(200);
1132:stk500boot.c  **** 	}
1133:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1134:stk500boot.c  **** #endif
1135:stk500boot.c  **** 
1136:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1137:stk500boot.c  **** 	sendchar('j');
1138:stk500boot.c  **** //	sendchar('u');
1139:stk500boot.c  **** //	sendchar('m');
1140:stk500boot.c  **** //	sendchar('p');
1141:stk500boot.c  **** //	sendchar(' ');
1142:stk500boot.c  **** //	sendchar('u');
1143:stk500boot.c  **** //	sendchar('s');
1144:stk500boot.c  **** //	sendchar('r');
1145:stk500boot.c  **** 	sendchar(0x0d);
1146:stk500boot.c  **** 	sendchar(0x0a);
1147:stk500boot.c  **** 
1148:stk500boot.c  **** 	delay_ms(100);
1149:stk500boot.c  **** #endif
1150:stk500boot.c  **** 
1151:stk500boot.c  **** 
1152:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1153:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1154:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1155:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1156:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1157:stk500boot.c  **** #endif
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 
1160:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1161:stk500boot.c  **** 
1162:stk500boot.c  **** 	/*
1163:stk500boot.c  **** 	 * Now leave bootloader
1164:stk500boot.c  **** 	 */
1165:stk500boot.c  **** 
1166:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1167:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1168:stk500boot.c  **** 
1169:stk500boot.c  **** 
1170:stk500boot.c  **** 	asm volatile(
1171:stk500boot.c  **** 			"clr	r30		\n\t"
1172:stk500boot.c  **** 			"clr	r31		\n\t"
1173:stk500boot.c  **** 			"ijmp	\n\t"
1174:stk500boot.c  **** 			);
1175:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1176:stk500boot.c  **** //					"push r1" "\n\t"
1177:stk500boot.c  **** //					"ret"	 "\n\t"
1178:stk500boot.c  **** //					::);
1179:stk500boot.c  **** 
1180:stk500boot.c  **** 	 /*
1181:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1182:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1183:stk500boot.c  **** 	 * understand this
1184:stk500boot.c  **** 	 */
1185:stk500boot.c  **** 	for(;;);
1186:stk500boot.c  **** }
1187:stk500boot.c  **** 
1188:stk500boot.c  **** /*
1189:stk500boot.c  **** base address = f800
1190:stk500boot.c  **** 
1191:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1192:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1193:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1194:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1195:stk500boot.c  **** avrdude>
1196:stk500boot.c  **** 
1197:stk500boot.c  **** 
1198:stk500boot.c  **** base address = f000
1199:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1200:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1201:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1202:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1203:stk500boot.c  **** avrdude>
1204:stk500boot.c  **** */
1205:stk500boot.c  **** 
1206:stk500boot.c  **** //************************************************************************
1207:stk500boot.c  **** #ifdef ENABLE_MONITOR
1208:stk500boot.c  **** #include	<math.h>
1209:stk500boot.c  **** 
1210:stk500boot.c  **** unsigned long	gRamIndex;
1211:stk500boot.c  **** unsigned long	gFlashIndex;
1212:stk500boot.c  **** unsigned long	gEepromIndex;
1213:stk500boot.c  **** 
1214:stk500boot.c  **** 
1215:stk500boot.c  **** #define	true	1
1216:stk500boot.c  **** #define	false	0
1217:stk500boot.c  **** 
1218:stk500boot.c  **** #include	"avr_cpunames.h"
1219:stk500boot.c  **** 
1220:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1221:stk500boot.c  **** 	#error cpu name not defined
1222:stk500boot.c  **** #endif
1223:stk500boot.c  **** 
1224:stk500boot.c  **** #ifdef _VECTORS_SIZE
1225:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1226:stk500boot.c  **** #else
1227:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1228:stk500boot.c  **** #endif
1229:stk500boot.c  **** 
1230:stk500boot.c  **** 
1231:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1232:stk500boot.c  **** 
1233:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1234:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1235:stk500boot.c  **** #else
1236:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1237:stk500boot.c  **** #endif
1238:stk500boot.c  **** 
1239:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1240:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1241:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1242:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1243:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1244:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1245:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1246:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1247:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1248:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1249:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1250:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1251:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1252:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1253:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1254:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1255:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1256:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1257:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1258:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1259:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1260:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1261:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1262:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1263:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1264:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1265:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1266:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1267:stk500boot.c  **** 
1268:stk500boot.c  **** 
1269:stk500boot.c  **** //************************************************************************
1270:stk500boot.c  **** //*	Help messages
1271:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1272:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1273:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1274:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1275:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1276:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1277:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1278:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1279:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1280:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1281:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1282:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1283:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1284:stk500boot.c  **** 
1285:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1286:stk500boot.c  **** 
1287:stk500boot.c  **** 
1288:stk500boot.c  **** //************************************************************************
1289:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1290:stk500boot.c  **** {
 162               		.loc 1 1290 0
 163               		.cfi_startproc
 164               	.LVL8:
 165 0036 CF93      		push r28
 166               	.LCFI0:
 167               		.cfi_def_cfa_offset 4
 168               		.cfi_offset 28, -3
 169 0038 DF93      		push r29
 170               	.LCFI1:
 171               		.cfi_def_cfa_offset 5
 172               		.cfi_offset 29, -4
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 2 */
 176               	.L__stack_usage = 2
1291:stk500boot.c  **** char	theChar;
1292:stk500boot.c  **** 
1293:stk500boot.c  **** 	dataPtr		+=	offset;
 177               		.loc 1 1293 0
 178 003a EC01      		movw r28,r24
 179 003c C60F      		add r28,r22
 180 003e D11D      		adc r29,__zero_reg__
 181               	.LVL9:
 182               	.L16:
 183               	.LBB53:
1294:stk500boot.c  **** 
1295:stk500boot.c  **** 	do {
1296:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1297:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 184               		.loc 1 1297 0
 185 0040 AE01      		movw r20,r28
 186 0042 60E0      		ldi r22,0
 187 0044 70E0      		ldi r23,0
 188               	/* #APP */
 189               	 ;  1297 "stk500boot.c" 1
 190 0046 6BBF      		out 59, r22
 191 0048 FA01      		movw r30, r20
 192 004a 8791      		elpm r24, Z+
 193               		
 194               	 ;  0 "" 2
 195               	.LVL10:
 196               	/* #NOAPP */
 197               	.LBE53:
1298:stk500boot.c  **** 	#else
1299:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1300:stk500boot.c  **** 	#endif
1301:stk500boot.c  **** 		if (theChar != 0)
 198               		.loc 1 1301 0
 199 004c 8823      		tst r24
 200 004e 01F0      		breq .L14
 201               	.LVL11:
 202               	.LBB54:
1297:stk500boot.c  **** 	#else
 203               		.loc 1 1297 0
 204 0050 2196      		adiw r28,1
 205               	.LVL12:
 206               	.LBE54:
1302:stk500boot.c  **** 		{
1303:stk500boot.c  **** 			sendchar(theChar);
 207               		.loc 1 1303 0
 208 0052 0E94 0000 		call sendchar
 209               	.LVL13:
 210 0056 00C0      		rjmp .L16
 211               	.LVL14:
 212               	.L14:
 213               	/* epilogue start */
1304:stk500boot.c  **** 		}
1305:stk500boot.c  **** 	} while (theChar != 0);
1306:stk500boot.c  **** }
 214               		.loc 1 1306 0
 215 0058 DF91      		pop r29
 216 005a CF91      		pop r28
 217 005c 0895      		ret
 218               		.cfi_endproc
 219               	.LFE18:
 221               	.global	PrintNewLine
 223               	PrintNewLine:
 224               	.LFB19:
1307:stk500boot.c  **** 
1308:stk500boot.c  **** //************************************************************************
1309:stk500boot.c  **** void	PrintNewLine(void)
1310:stk500boot.c  **** {
 225               		.loc 1 1310 0
 226               		.cfi_startproc
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
1311:stk500boot.c  **** 	sendchar(0x0d);
 231               		.loc 1 1311 0
 232 005e 8DE0      		ldi r24,lo8(13)
 233 0060 0E94 0000 		call sendchar
 234               	.LVL15:
1312:stk500boot.c  **** 	sendchar(0x0a);
 235               		.loc 1 1312 0
 236 0064 8AE0      		ldi r24,lo8(10)
 237 0066 0C94 0000 		jmp sendchar
 238               	.LVL16:
 239               		.cfi_endproc
 240               	.LFE19:
 242               		.section	.text.unlikely
 244               	PrintAvailablePort:
 245               	.LFB29:
1313:stk500boot.c  **** }
1314:stk500boot.c  **** 
1315:stk500boot.c  **** 
1316:stk500boot.c  **** //************************************************************************
1317:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1318:stk500boot.c  **** {
1319:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1320:stk500boot.c  **** 
1321:stk500boot.c  **** 	PrintNewLine();
1322:stk500boot.c  **** }
1323:stk500boot.c  **** 
1324:stk500boot.c  **** 
1325:stk500boot.c  **** //************************************************************************
1326:stk500boot.c  **** void	PrintString(char *textString)
1327:stk500boot.c  **** {
1328:stk500boot.c  **** char	theChar;
1329:stk500boot.c  **** int		ii;
1330:stk500boot.c  **** 
1331:stk500boot.c  **** 	theChar		=	1;
1332:stk500boot.c  **** 	ii			=	0;
1333:stk500boot.c  **** 	while (theChar != 0)
1334:stk500boot.c  **** 	{
1335:stk500boot.c  **** 		theChar	=	textString[ii];
1336:stk500boot.c  **** 		if (theChar != 0)
1337:stk500boot.c  **** 		{
1338:stk500boot.c  **** 			sendchar(theChar);
1339:stk500boot.c  **** 		}
1340:stk500boot.c  **** 		ii++;
1341:stk500boot.c  **** 	}
1342:stk500boot.c  **** }
1343:stk500boot.c  **** 
1344:stk500boot.c  **** //************************************************************************
1345:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1346:stk500boot.c  **** {
1347:stk500boot.c  **** char	theChar;
1348:stk500boot.c  **** 
1349:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1350:stk500boot.c  **** 	if (theChar > 0x39)
1351:stk500boot.c  **** 	{
1352:stk500boot.c  **** 		theChar	+=	7;
1353:stk500boot.c  **** 	}
1354:stk500boot.c  **** 	sendchar(theChar );
1355:stk500boot.c  **** 
1356:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1357:stk500boot.c  **** 	if (theChar > 0x39)
1358:stk500boot.c  **** 	{
1359:stk500boot.c  **** 		theChar	+=	7;
1360:stk500boot.c  **** 	}
1361:stk500boot.c  **** 	sendchar(theChar );
1362:stk500boot.c  **** }
1363:stk500boot.c  **** 
1364:stk500boot.c  **** //************************************************************************
1365:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1366:stk500boot.c  **** {
1367:stk500boot.c  **** int	theChar;
1368:stk500boot.c  **** int	myNumber;
1369:stk500boot.c  **** 
1370:stk500boot.c  **** 	myNumber	=	theNumber;
1371:stk500boot.c  **** 
1372:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1373:stk500boot.c  **** 	{
1374:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1375:stk500boot.c  **** 		sendchar(theChar );
1376:stk500boot.c  **** 	}
1377:stk500boot.c  **** 
1378:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1379:stk500boot.c  **** 	{
1380:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1381:stk500boot.c  **** 		sendchar(theChar );
1382:stk500boot.c  **** 	}
1383:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1384:stk500boot.c  **** 	sendchar(theChar );
1385:stk500boot.c  **** }
1386:stk500boot.c  **** 
1387:stk500boot.c  **** 
1388:stk500boot.c  **** 
1389:stk500boot.c  **** 
1390:stk500boot.c  **** //************************************************************************
1391:stk500boot.c  **** static void	PrintCPUstats(void)
1392:stk500boot.c  **** {
1393:stk500boot.c  **** unsigned char fuseByte;
1394:stk500boot.c  **** 
1395:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1396:stk500boot.c  **** 
1397:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1398:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1399:stk500boot.c  **** 
1400:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1401:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1402:stk500boot.c  **** 
1403:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1404:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1405:stk500boot.c  **** 	PrintNewLine();
1406:stk500boot.c  **** 
1407:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1408:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1409:stk500boot.c  **** 
1410:stk500boot.c  **** 	//*	these can be found in avr/version.h
1411:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1412:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1413:stk500boot.c  **** 
1414:stk500boot.c  **** #if defined(SIGNATURE_0)
1415:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1416:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1417:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1418:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1419:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1420:stk500boot.c  **** 	PrintNewLine();
1421:stk500boot.c  **** #endif
1422:stk500boot.c  **** 
1423:stk500boot.c  **** 
1424:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1425:stk500boot.c  **** 	//*	fuse settings
1426:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1427:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1428:stk500boot.c  **** 	PrintHexByte(fuseByte);
1429:stk500boot.c  **** 	PrintNewLine();
1430:stk500boot.c  **** 
1431:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1432:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1433:stk500boot.c  **** 	PrintHexByte(fuseByte);
1434:stk500boot.c  **** 	PrintNewLine();
1435:stk500boot.c  **** 
1436:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1437:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1438:stk500boot.c  **** 	PrintHexByte(fuseByte);
1439:stk500boot.c  **** 	PrintNewLine();
1440:stk500boot.c  **** 
1441:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1442:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1443:stk500boot.c  **** 	PrintHexByte(fuseByte);
1444:stk500boot.c  **** 	PrintNewLine();
1445:stk500boot.c  **** 
1446:stk500boot.c  **** #endif
1447:stk500boot.c  **** 
1448:stk500boot.c  **** }
1449:stk500boot.c  **** 
1450:stk500boot.c  **** 
1451:stk500boot.c  **** //************************************************************************
1452:stk500boot.c  **** static void BlinkLED(void)
1453:stk500boot.c  **** {
1454:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1455:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1456:stk500boot.c  **** 
1457:stk500boot.c  **** 	while (!Serial_Available())
1458:stk500boot.c  **** 	{
1459:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1460:stk500boot.c  **** 		delay_ms(100);
1461:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1462:stk500boot.c  **** 		delay_ms(100);
1463:stk500boot.c  **** 	}
1464:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1465:stk500boot.c  **** }
1466:stk500boot.c  **** 
1467:stk500boot.c  **** enum
1468:stk500boot.c  **** {
1469:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1470:stk500boot.c  **** 	kDUMP_EEPROM,
1471:stk500boot.c  **** 	kDUMP_RAM
1472:stk500boot.c  **** };
1473:stk500boot.c  **** 
1474:stk500boot.c  **** //************************************************************************
1475:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1476:stk500boot.c  **** {
1477:stk500boot.c  **** unsigned long	myAddressPointer;
1478:stk500boot.c  **** uint8_t			ii;
1479:stk500boot.c  **** unsigned char	theValue;
1480:stk500boot.c  **** char			asciiDump[18];
1481:stk500boot.c  **** unsigned char	*ramPtr;
1482:stk500boot.c  **** 
1483:stk500boot.c  **** 
1484:stk500boot.c  **** 	ramPtr				=	0;
1485:stk500boot.c  **** 	theValue			=	0;
1486:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1487:stk500boot.c  **** 	while (numRows > 0)
1488:stk500boot.c  **** 	{
1489:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1490:stk500boot.c  **** 		{
1491:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1492:stk500boot.c  **** 		}
1493:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1494:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1495:stk500boot.c  **** 		sendchar(0x20);
1496:stk500boot.c  **** 		sendchar('-');
1497:stk500boot.c  **** 		sendchar(0x20);
1498:stk500boot.c  **** 
1499:stk500boot.c  **** 		asciiDump[0]		=	0;
1500:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1501:stk500boot.c  **** 		{
1502:stk500boot.c  **** 			switch(dumpWhat)
1503:stk500boot.c  **** 			{
1504:stk500boot.c  **** 				case kDUMP_FLASH:
1505:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1506:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1507:stk500boot.c  **** 				#else
1508:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1509:stk500boot.c  **** 				#endif
1510:stk500boot.c  **** 					break;
1511:stk500boot.c  **** 
1512:stk500boot.c  **** 				case kDUMP_EEPROM:
1513:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1514:stk500boot.c  **** 					break;
1515:stk500boot.c  **** 
1516:stk500boot.c  **** 				case kDUMP_RAM:
1517:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1518:stk500boot.c  **** 					break;
1519:stk500boot.c  **** 
1520:stk500boot.c  **** 			}
1521:stk500boot.c  **** 			PrintHexByte(theValue);
1522:stk500boot.c  **** 			sendchar(0x20);
1523:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1524:stk500boot.c  **** 			{
1525:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1526:stk500boot.c  **** 			}
1527:stk500boot.c  **** 			else
1528:stk500boot.c  **** 			{
1529:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1530:stk500boot.c  **** 			}
1531:stk500boot.c  **** 
1532:stk500boot.c  **** 			myAddressPointer++;
1533:stk500boot.c  **** 		}
1534:stk500boot.c  **** 		asciiDump[16]	=	0;
1535:stk500boot.c  **** 		PrintString(asciiDump);
1536:stk500boot.c  **** 		PrintNewLine();
1537:stk500boot.c  **** 
1538:stk500boot.c  **** 		numRows--;
1539:stk500boot.c  **** 	}
1540:stk500boot.c  **** }
1541:stk500boot.c  **** 
1542:stk500boot.c  **** 
1543:stk500boot.c  **** 
1544:stk500boot.c  **** //************************************************************************
1545:stk500boot.c  **** //*	returns amount of extended memory
1546:stk500boot.c  **** static void	EEPROMtest(void)
1547:stk500boot.c  **** {
1548:stk500boot.c  **** int		ii;
1549:stk500boot.c  **** char	theChar;
1550:stk500boot.c  **** char	theEEPROMchar;
1551:stk500boot.c  **** int		errorCount;
1552:stk500boot.c  **** 
1553:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1554:stk500boot.c  **** 	PrintNewLine();
1555:stk500boot.c  **** 	ii			=	0;
1556:stk500boot.c  **** #if (FLASHEND > 0x10000)
1557:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1558:stk500boot.c  **** #else
1559:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1560:stk500boot.c  **** #endif
1561:stk500boot.c  **** 	{
1562:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1563:stk500boot.c  **** 		if (theChar == 0)
1564:stk500boot.c  **** 		{
1565:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1566:stk500boot.c  **** 		}
1567:stk500boot.c  **** 		else
1568:stk500boot.c  **** 		{
1569:stk500boot.c  **** 			sendchar(theChar);
1570:stk500boot.c  **** 		}
1571:stk500boot.c  **** 		ii++;
1572:stk500boot.c  **** 	}
1573:stk500boot.c  **** 
1574:stk500boot.c  **** 	//*	no go back through and test
1575:stk500boot.c  **** 	PrintNewLine();
1576:stk500boot.c  **** 	PrintNewLine();
1577:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1578:stk500boot.c  **** 	PrintNewLine();
1579:stk500boot.c  **** 	errorCount	=	0;
1580:stk500boot.c  **** 	ii			=	0;
1581:stk500boot.c  **** #if (FLASHEND > 0x10000)
1582:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1583:stk500boot.c  **** #else
1584:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1585:stk500boot.c  **** #endif
1586:stk500boot.c  **** 	{
1587:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1588:stk500boot.c  **** 		if (theEEPROMchar == 0)
1589:stk500boot.c  **** 		{
1590:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1591:stk500boot.c  **** 		}
1592:stk500boot.c  **** 		else
1593:stk500boot.c  **** 		{
1594:stk500boot.c  **** 			sendchar(theEEPROMchar);
1595:stk500boot.c  **** 		}
1596:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1597:stk500boot.c  **** 		{
1598:stk500boot.c  **** 			errorCount++;
1599:stk500boot.c  **** 		}
1600:stk500boot.c  **** 		ii++;
1601:stk500boot.c  **** 	}
1602:stk500boot.c  **** 	PrintNewLine();
1603:stk500boot.c  **** 	PrintNewLine();
1604:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1605:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1606:stk500boot.c  **** 	PrintNewLine();
1607:stk500boot.c  **** 	PrintNewLine();
1608:stk500boot.c  **** 
1609:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1610:stk500boot.c  **** 
1611:stk500boot.c  **** }
1612:stk500boot.c  **** 
1613:stk500boot.c  **** 
1614:stk500boot.c  **** 
1615:stk500boot.c  **** #if (FLASHEND > 0x08000)
1616:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1617:stk500boot.c  **** //*	memory to include this
1618:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1619:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1620:stk500boot.c  **** //		#warning Interrupt vectors not defined
1621:stk500boot.c  **** //	#endif
1622:stk500boot.c  **** #endif
1623:stk500boot.c  **** 
1624:stk500boot.c  **** //************************************************************************
1625:stk500boot.c  **** static void	VectorDisplay(void)
1626:stk500boot.c  **** {
1627:stk500boot.c  **** unsigned long	byte1;
1628:stk500boot.c  **** unsigned long	byte2;
1629:stk500boot.c  **** unsigned long	byte3;
1630:stk500boot.c  **** unsigned long	byte4;
1631:stk500boot.c  **** unsigned long	word1;
1632:stk500boot.c  **** unsigned long	word2;
1633:stk500boot.c  **** int				vectorIndex;
1634:stk500boot.c  **** unsigned long	myMemoryPtr;
1635:stk500boot.c  **** unsigned long	wordMemoryAddress;
1636:stk500boot.c  **** unsigned long	realitiveAddr;
1637:stk500boot.c  **** unsigned long	myFullAddress;
1638:stk500boot.c  **** unsigned long	absoluteAddr;
1639:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1640:stk500boot.c  **** 	long		stringPointer;
1641:stk500boot.c  **** #endif
1642:stk500boot.c  **** 
1643:stk500boot.c  **** 	myMemoryPtr		=	0;
1644:stk500boot.c  **** 	vectorIndex		=	0;
1645:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1646:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1647:stk500boot.c  **** 	//					 V#   ADDR   op code
1648:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1649:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1650:stk500boot.c  **** 	{
1651:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1652:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1653:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1654:stk500boot.c  **** 		sendchar(0x20);
1655:stk500boot.c  **** 		sendchar('-');
1656:stk500boot.c  **** 		sendchar(0x20);
1657:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1658:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1659:stk500boot.c  **** 		sendchar(0x20);
1660:stk500boot.c  **** 		sendchar('=');
1661:stk500boot.c  **** 		sendchar(0x20);
1662:stk500boot.c  **** 
1663:stk500boot.c  **** 	
1664:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1665:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1666:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1667:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1668:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1669:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1670:stk500boot.c  **** 	#else
1671:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1672:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1673:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1674:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1675:stk500boot.c  **** 	#endif
1676:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1677:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1678:stk500boot.c  **** 
1679:stk500boot.c  **** 
1680:stk500boot.c  **** 		PrintHexByte(byte2);
1681:stk500boot.c  **** 		sendchar(0x20);
1682:stk500boot.c  **** 		PrintHexByte(byte1);
1683:stk500boot.c  **** 		sendchar(0x20);
1684:stk500boot.c  **** 		PrintHexByte(byte4);
1685:stk500boot.c  **** 		sendchar(0x20);
1686:stk500boot.c  **** 		PrintHexByte(byte3);
1687:stk500boot.c  **** 		sendchar(0x20);
1688:stk500boot.c  **** 	
1689:stk500boot.c  **** 		if (word1 == 0xffff)
1690:stk500boot.c  **** 		{
1691:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1692:stk500boot.c  **** 		}
1693:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1694:stk500boot.c  **** 		{
1695:stk500boot.c  **** 			//*	rjmp instruction
1696:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1697:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1698:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1699:stk500boot.c  **** 
1700:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1701:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1702:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1703:stk500boot.c  **** 			sendchar(0x20);
1704:stk500boot.c  **** 			sendchar('>');
1705:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1706:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1707:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1708:stk500boot.c  **** 	
1709:stk500boot.c  **** 		}
1710:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1711:stk500boot.c  **** 		{
1712:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1713:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1714:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1715:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1716:stk500boot.c  **** 								word2;
1717:stk500boot.c  **** 							
1718:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1719:stk500boot.c  **** 							
1720:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1721:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1722:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1723:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1724:stk500boot.c  **** 			sendchar(0x20);
1725:stk500boot.c  **** 			sendchar('>');
1726:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1727:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1728:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1729:stk500boot.c  **** 		}
1730:stk500boot.c  **** 
1731:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1732:stk500boot.c  **** 		sendchar(0x20);
1733:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1734:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1735:stk500boot.c  **** 	#else
1736:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1737:stk500boot.c  **** 	#endif
1738:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1739:stk500boot.c  **** 	#endif
1740:stk500boot.c  **** 		PrintNewLine();
1741:stk500boot.c  **** 
1742:stk500boot.c  **** 		vectorIndex++;
1743:stk500boot.c  **** 	}
1744:stk500boot.c  **** }
1745:stk500boot.c  **** 
1746:stk500boot.c  **** //************************************************************************
1747:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1748:stk500boot.c  **** {
 246               		.loc 1 1748 0
 247               		.cfi_startproc
 248               	.LVL17:
 249 000e CF93      		push r28
 250               	.LCFI2:
 251               		.cfi_def_cfa_offset 4
 252               		.cfi_offset 28, -3
 253               	/* prologue: function */
 254               	/* frame size = 0 */
 255               	/* stack size = 1 */
 256               	.L__stack_usage = 1
 257 0010 C82F      		mov r28,r24
1749:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 258               		.loc 1 1749 0
 259 0012 60E0      		ldi r22,0
 260 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 261 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 262               	.LVL18:
 263 0018 0E94 0000 		call PrintFromPROGMEM
 264               	.LVL19:
1750:stk500boot.c  **** 	sendchar(thePortLetter);
 265               		.loc 1 1750 0
 266 001c 8C2F      		mov r24,r28
 267 001e 0E94 0000 		call sendchar
 268               	.LVL20:
 269               	/* epilogue start */
1751:stk500boot.c  **** 	PrintNewLine();
1752:stk500boot.c  **** }
 270               		.loc 1 1752 0
 271 0022 CF91      		pop r28
 272               	.LVL21:
1751:stk500boot.c  **** 	PrintNewLine();
 273               		.loc 1 1751 0
 274 0024 0C94 0000 		jmp PrintNewLine
 275               	.LVL22:
 276               		.cfi_endproc
 277               	.LFE29:
 279               		.text
 280               	.global	PrintFromPROGMEMln
 282               	PrintFromPROGMEMln:
 283               	.LFB20:
1318:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 284               		.loc 1 1318 0
 285               		.cfi_startproc
 286               	.LVL23:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 0 */
 290               	.L__stack_usage = 0
1319:stk500boot.c  **** 
 291               		.loc 1 1319 0
 292 006a 0E94 0000 		call PrintFromPROGMEM
 293               	.LVL24:
1321:stk500boot.c  **** }
 294               		.loc 1 1321 0
 295 006e 0C94 0000 		jmp PrintNewLine
 296               	.LVL25:
 297               		.cfi_endproc
 298               	.LFE20:
 300               	.global	PrintString
 302               	PrintString:
 303               	.LFB21:
1327:stk500boot.c  **** char	theChar;
 304               		.loc 1 1327 0
 305               		.cfi_startproc
 306               	.LVL26:
 307 0072 CF93      		push r28
 308               	.LCFI3:
 309               		.cfi_def_cfa_offset 4
 310               		.cfi_offset 28, -3
 311 0074 DF93      		push r29
 312               	.LCFI4:
 313               		.cfi_def_cfa_offset 5
 314               		.cfi_offset 29, -4
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 2 */
 318               	.L__stack_usage = 2
 319 0076 EC01      		movw r28,r24
 320               	.LVL27:
 321               	.L22:
1335:stk500boot.c  **** 		if (theChar != 0)
 322               		.loc 1 1335 0
 323 0078 8991      		ld r24,Y+
 324               	.LVL28:
1336:stk500boot.c  **** 		{
 325               		.loc 1 1336 0
 326 007a 8823      		tst r24
 327 007c 01F0      		breq .L20
1338:stk500boot.c  **** 		}
 328               		.loc 1 1338 0
 329 007e 0E94 0000 		call sendchar
 330               	.LVL29:
 331 0082 00C0      		rjmp .L22
 332               	.LVL30:
 333               	.L20:
 334               	/* epilogue start */
1342:stk500boot.c  **** 
 335               		.loc 1 1342 0
 336 0084 DF91      		pop r29
 337 0086 CF91      		pop r28
 338               	.LVL31:
 339 0088 0895      		ret
 340               		.cfi_endproc
 341               	.LFE21:
 343               	.global	PrintHexByte
 345               	PrintHexByte:
 346               	.LFB22:
1346:stk500boot.c  **** char	theChar;
 347               		.loc 1 1346 0
 348               		.cfi_startproc
 349               	.LVL32:
 350 008a CF93      		push r28
 351               	.LCFI5:
 352               		.cfi_def_cfa_offset 4
 353               		.cfi_offset 28, -3
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 1 */
 357               	.L__stack_usage = 1
 358 008c C82F      		mov r28,r24
1349:stk500boot.c  **** 	if (theChar > 0x39)
 359               		.loc 1 1349 0
 360 008e 982F      		mov r25,r24
 361 0090 9295      		swap r25
 362 0092 9F70      		andi r25,lo8(15)
 363 0094 80E3      		ldi r24,lo8(48)
 364               	.LVL33:
 365 0096 890F      		add r24,r25
 366               	.LVL34:
1350:stk500boot.c  **** 	{
 367               		.loc 1 1350 0
 368 0098 8A33      		cpi r24,lo8(58)
 369 009a 00F0      		brlo .L24
1352:stk500boot.c  **** 	}
 370               		.loc 1 1352 0
 371 009c 87E3      		ldi r24,lo8(55)
 372               	.LVL35:
 373 009e 890F      		add r24,r25
 374               	.LVL36:
 375               	.L24:
1354:stk500boot.c  **** 
 376               		.loc 1 1354 0
 377 00a0 0E94 0000 		call sendchar
 378               	.LVL37:
1356:stk500boot.c  **** 	if (theChar > 0x39)
 379               		.loc 1 1356 0
 380 00a4 CF70      		andi r28,lo8(15)
 381               	.LVL38:
 382 00a6 80E3      		ldi r24,lo8(48)
 383 00a8 8C0F      		add r24,r28
 384               	.LVL39:
1357:stk500boot.c  **** 	{
 385               		.loc 1 1357 0
 386 00aa 8A33      		cpi r24,lo8(58)
 387 00ac 00F0      		brlo .L25
1359:stk500boot.c  **** 	}
 388               		.loc 1 1359 0
 389 00ae 87E3      		ldi r24,lo8(55)
 390               	.LVL40:
 391 00b0 8C0F      		add r24,r28
 392               	.LVL41:
 393               	.L25:
 394               	/* epilogue start */
1362:stk500boot.c  **** 
 395               		.loc 1 1362 0
 396 00b2 CF91      		pop r28
1361:stk500boot.c  **** }
 397               		.loc 1 1361 0
 398 00b4 0C94 0000 		jmp sendchar
 399               	.LVL42:
 400               		.cfi_endproc
 401               	.LFE22:
 403               		.section	.text.unlikely
 405               	DumpHex.constprop.0:
 406               	.LFB34:
1475:stk500boot.c  **** {
 407               		.loc 1 1475 0
 408               		.cfi_startproc
 409               	.LVL43:
 410 0028 2F92      		push r2
 411               	.LCFI6:
 412               		.cfi_def_cfa_offset 4
 413               		.cfi_offset 2, -3
 414 002a 3F92      		push r3
 415               	.LCFI7:
 416               		.cfi_def_cfa_offset 5
 417               		.cfi_offset 3, -4
 418 002c 4F92      		push r4
 419               	.LCFI8:
 420               		.cfi_def_cfa_offset 6
 421               		.cfi_offset 4, -5
 422 002e 5F92      		push r5
 423               	.LCFI9:
 424               		.cfi_def_cfa_offset 7
 425               		.cfi_offset 5, -6
 426 0030 6F92      		push r6
 427               	.LCFI10:
 428               		.cfi_def_cfa_offset 8
 429               		.cfi_offset 6, -7
 430 0032 7F92      		push r7
 431               	.LCFI11:
 432               		.cfi_def_cfa_offset 9
 433               		.cfi_offset 7, -8
 434 0034 8F92      		push r8
 435               	.LCFI12:
 436               		.cfi_def_cfa_offset 10
 437               		.cfi_offset 8, -9
 438 0036 9F92      		push r9
 439               	.LCFI13:
 440               		.cfi_def_cfa_offset 11
 441               		.cfi_offset 9, -10
 442 0038 AF92      		push r10
 443               	.LCFI14:
 444               		.cfi_def_cfa_offset 12
 445               		.cfi_offset 10, -11
 446 003a BF92      		push r11
 447               	.LCFI15:
 448               		.cfi_def_cfa_offset 13
 449               		.cfi_offset 11, -12
 450 003c CF92      		push r12
 451               	.LCFI16:
 452               		.cfi_def_cfa_offset 14
 453               		.cfi_offset 12, -13
 454 003e DF92      		push r13
 455               	.LCFI17:
 456               		.cfi_def_cfa_offset 15
 457               		.cfi_offset 13, -14
 458 0040 EF92      		push r14
 459               	.LCFI18:
 460               		.cfi_def_cfa_offset 16
 461               		.cfi_offset 14, -15
 462 0042 FF92      		push r15
 463               	.LCFI19:
 464               		.cfi_def_cfa_offset 17
 465               		.cfi_offset 15, -16
 466 0044 0F93      		push r16
 467               	.LCFI20:
 468               		.cfi_def_cfa_offset 18
 469               		.cfi_offset 16, -17
 470 0046 1F93      		push r17
 471               	.LCFI21:
 472               		.cfi_def_cfa_offset 19
 473               		.cfi_offset 17, -18
 474 0048 CF93      		push r28
 475               	.LCFI22:
 476               		.cfi_def_cfa_offset 20
 477               		.cfi_offset 28, -19
 478 004a DF93      		push r29
 479               	.LCFI23:
 480               		.cfi_def_cfa_offset 21
 481               		.cfi_offset 29, -20
 482 004c CDB7      		in r28,__SP_L__
 483 004e DEB7      		in r29,__SP_H__
 484               	.LCFI24:
 485               		.cfi_def_cfa_register 28
 486 0050 6397      		sbiw r28,19
 487               	.LCFI25:
 488               		.cfi_def_cfa_offset 40
 489 0052 0FB6      		in __tmp_reg__,__SREG__
 490 0054 F894      		cli
 491 0056 DEBF      		out __SP_H__,r29
 492 0058 0FBE      		out __SREG__,__tmp_reg__
 493 005a CDBF      		out __SP_L__,r28
 494               	/* prologue: function */
 495               	/* frame size = 19 */
 496               	/* stack size = 37 */
 497               	.L__stack_usage = 37
 498 005c 8B8B      		std Y+19,r24
 499 005e 6A01      		movw r12,r20
 500 0060 7B01      		movw r14,r22
 501               	.LVL44:
1475:stk500boot.c  **** {
 502               		.loc 1 1475 0
 503 0062 00E1      		ldi r16,lo8(16)
1485:stk500boot.c  **** 	myAddressPointer	=	startAddress;
 504               		.loc 1 1485 0
 505 0064 10E0      		ldi r17,0
 506 0066 CE01      		movw r24,r28
 507               	.LVL45:
 508 0068 0196      		adiw r24,1
 509 006a 4C01      		movw r8,r24
1529:stk500boot.c  **** 			}
 510               		.loc 1 1529 0
 511 006c 8EE2      		ldi r24,lo8(46)
 512 006e 382E      		mov r3,r24
 513 0070 90E1      		ldi r25,lo8(16)
 514 0072 292E      		mov r2,r25
 515 0074 280C      		add r2,r8
 516               	.LVL46:
 517               	.L35:
1489:stk500boot.c  **** 		{
 518               		.loc 1 1489 0
 519 0076 91E0      		ldi r25,1
 520 0078 C916      		cp r12,r25
 521 007a D104      		cpc r13,__zero_reg__
 522 007c E906      		cpc r14,r25
 523 007e F104      		cpc r15,__zero_reg__
 524 0080 00F0      		brlo .L27
1491:stk500boot.c  **** 		}
 525               		.loc 1 1491 0
 526 0082 8E2D      		mov r24,r14
 527 0084 0E94 0000 		call PrintHexByte
 528               	.LVL47:
 529               	.L27:
1493:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 530               		.loc 1 1493 0
 531 0088 8D2D      		mov r24,r13
 532 008a 0E94 0000 		call PrintHexByte
 533               	.LVL48:
1494:stk500boot.c  **** 		sendchar(0x20);
 534               		.loc 1 1494 0
 535 008e 8C2D      		mov r24,r12
 536 0090 0E94 0000 		call PrintHexByte
 537               	.LVL49:
1495:stk500boot.c  **** 		sendchar('-');
 538               		.loc 1 1495 0
 539 0094 80E2      		ldi r24,lo8(32)
 540 0096 0E94 0000 		call sendchar
 541               	.LVL50:
1496:stk500boot.c  **** 		sendchar(0x20);
 542               		.loc 1 1496 0
 543 009a 8DE2      		ldi r24,lo8(45)
 544 009c 0E94 0000 		call sendchar
 545               	.LVL51:
1497:stk500boot.c  **** 
 546               		.loc 1 1497 0
 547 00a0 80E2      		ldi r24,lo8(32)
 548 00a2 0E94 0000 		call sendchar
 549               	.LVL52:
1499:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 550               		.loc 1 1499 0
 551 00a6 1982      		std Y+1,__zero_reg__
 552               	.LVL53:
 553 00a8 5401      		movw r10,r8
 554 00aa 2601      		movw r4,r12
 555 00ac 3701      		movw r6,r14
 556               	.LVL54:
 557               	.L34:
1502:stk500boot.c  **** 			{
 558               		.loc 1 1502 0
 559 00ae EB89      		ldd r30,Y+19
 560 00b0 E130      		cpi r30,lo8(1)
 561 00b2 01F0      		breq .L29
 562 00b4 00F0      		brlo .L30
 563 00b6 E230      		cpi r30,lo8(2)
 564 00b8 01F4      		brne .L28
1517:stk500boot.c  **** 					break;
 565               		.loc 1 1517 0
 566 00ba F201      		movw r30,r4
 567 00bc 1081      		ld r17,Z
 568               	.LVL55:
 569 00be 00C0      		rjmp .L28
 570               	.L30:
 571               	.LVL56:
 572               	.LBB55:
1506:stk500boot.c  **** 				#else
 573               		.loc 1 1506 0
 574               	/* #APP */
 575               	 ;  1506 "stk500boot.c" 1
 576 00c0 6BBE      		out 59, r6
 577 00c2 F201      		movw r30, r4
 578 00c4 1791      		elpm r17, Z+
 579               		
 580               	 ;  0 "" 2
 581               	.LVL57:
 582               	/* #NOAPP */
 583 00c6 00C0      		rjmp .L28
 584               	.LVL58:
 585               	.L29:
 586               	.LBE55:
1513:stk500boot.c  **** 					break;
 587               		.loc 1 1513 0
 588 00c8 C201      		movw r24,r4
 589 00ca 0E94 0000 		call eeprom_read_byte
 590               	.LVL59:
 591 00ce 182F      		mov r17,r24
 592               	.LVL60:
 593               	.L28:
1521:stk500boot.c  **** 			sendchar(0x20);
 594               		.loc 1 1521 0
 595 00d0 812F      		mov r24,r17
 596 00d2 0E94 0000 		call PrintHexByte
 597               	.LVL61:
1522:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 598               		.loc 1 1522 0
 599 00d6 80E2      		ldi r24,lo8(32)
 600 00d8 0E94 0000 		call sendchar
 601               	.LVL62:
1523:stk500boot.c  **** 			{
 602               		.loc 1 1523 0
 603 00dc 80EE      		ldi r24,lo8(-32)
 604 00de 810F      		add r24,r17
1525:stk500boot.c  **** 			}
 605               		.loc 1 1525 0
 606 00e0 F501      		movw r30,r10
1523:stk500boot.c  **** 			{
 607               		.loc 1 1523 0
 608 00e2 8F35      		cpi r24,lo8(95)
 609 00e4 00F4      		brsh .L32
1525:stk500boot.c  **** 			}
 610               		.loc 1 1525 0
 611 00e6 1083      		st Z,r17
 612 00e8 00C0      		rjmp .L33
 613               	.L32:
1529:stk500boot.c  **** 			}
 614               		.loc 1 1529 0
 615 00ea 3082      		st Z,r3
 616               	.L33:
1532:stk500boot.c  **** 		}
 617               		.loc 1 1532 0
 618 00ec FFEF      		ldi r31,-1
 619 00ee 4F1A      		sub r4,r31
 620 00f0 5F0A      		sbc r5,r31
 621 00f2 6F0A      		sbc r6,r31
 622 00f4 7F0A      		sbc r7,r31
 623               	.LVL63:
 624 00f6 8FEF      		ldi r24,-1
 625 00f8 A81A      		sub r10,r24
 626 00fa B80A      		sbc r11,r24
1500:stk500boot.c  **** 		{
 627               		.loc 1 1500 0
 628 00fc 2A10      		cpse r2,r10
 629 00fe 00C0      		rjmp .L34
 630 0100 90E1      		ldi r25,16
 631 0102 C90E      		add r12,r25
 632 0104 D11C      		adc r13,__zero_reg__
 633 0106 E11C      		adc r14,__zero_reg__
 634 0108 F11C      		adc r15,__zero_reg__
1534:stk500boot.c  **** 		PrintString(asciiDump);
 635               		.loc 1 1534 0
 636 010a 198A      		std Y+17,__zero_reg__
1535:stk500boot.c  **** 		PrintNewLine();
 637               		.loc 1 1535 0
 638 010c C401      		movw r24,r8
 639 010e 0E94 0000 		call PrintString
 640               	.LVL64:
1536:stk500boot.c  **** 
 641               		.loc 1 1536 0
 642 0112 0E94 0000 		call PrintNewLine
 643               	.LVL65:
 644 0116 0150      		subi r16,lo8(-(-1))
 645               	.LVL66:
1487:stk500boot.c  **** 	{
 646               		.loc 1 1487 0
 647 0118 01F0      		breq .+2
 648 011a 00C0      		rjmp .L35
 649               	/* epilogue start */
1540:stk500boot.c  **** 
 650               		.loc 1 1540 0
 651 011c 6396      		adiw r28,19
 652               	.LVL67:
 653 011e 0FB6      		in __tmp_reg__,__SREG__
 654 0120 F894      		cli
 655 0122 DEBF      		out __SP_H__,r29
 656 0124 0FBE      		out __SREG__,__tmp_reg__
 657 0126 CDBF      		out __SP_L__,r28
 658 0128 DF91      		pop r29
 659 012a CF91      		pop r28
 660               	.LVL68:
 661 012c 1F91      		pop r17
 662               	.LVL69:
 663 012e 0F91      		pop r16
 664               	.LVL70:
 665 0130 FF90      		pop r15
 666 0132 EF90      		pop r14
 667 0134 DF90      		pop r13
 668 0136 CF90      		pop r12
 669               	.LVL71:
 670 0138 BF90      		pop r11
 671 013a AF90      		pop r10
 672 013c 9F90      		pop r9
 673 013e 8F90      		pop r8
 674 0140 7F90      		pop r7
 675 0142 6F90      		pop r6
 676 0144 5F90      		pop r5
 677 0146 4F90      		pop r4
 678 0148 3F90      		pop r3
 679 014a 2F90      		pop r2
 680 014c 0895      		ret
 681               		.cfi_endproc
 682               	.LFE34:
 684               		.text
 685               	.global	PrintDecInt
 687               	PrintDecInt:
 688               	.LFB23:
1366:stk500boot.c  **** int	theChar;
 689               		.loc 1 1366 0
 690               		.cfi_startproc
 691               	.LVL72:
 692 00b8 0F93      		push r16
 693               	.LCFI26:
 694               		.cfi_def_cfa_offset 4
 695               		.cfi_offset 16, -3
 696 00ba 1F93      		push r17
 697               	.LCFI27:
 698               		.cfi_def_cfa_offset 5
 699               		.cfi_offset 17, -4
 700 00bc CF93      		push r28
 701               	.LCFI28:
 702               		.cfi_def_cfa_offset 6
 703               		.cfi_offset 28, -5
 704 00be DF93      		push r29
 705               	.LCFI29:
 706               		.cfi_def_cfa_offset 7
 707               		.cfi_offset 29, -6
 708               	/* prologue: function */
 709               	/* frame size = 0 */
 710               	/* stack size = 4 */
 711               	.L__stack_usage = 4
 712 00c0 EC01      		movw r28,r24
 713 00c2 8B01      		movw r16,r22
 714               	.LVL73:
1372:stk500boot.c  **** 	{
 715               		.loc 1 1372 0
 716 00c4 8536      		cpi r24,101
 717 00c6 9105      		cpc r25,__zero_reg__
 718 00c8 04F4      		brge .L39
1372:stk500boot.c  **** 	{
 719               		.loc 1 1372 0 is_stmt 0 discriminator 1
 720 00ca 6330      		cpi r22,3
 721 00cc 7105      		cpc r23,__zero_reg__
 722 00ce 04F0      		brlt .L40
 723               	.L39:
 724               	.LVL74:
1374:stk500boot.c  **** 		sendchar(theChar );
 725               		.loc 1 1374 0 is_stmt 1
 726 00d0 CE01      		movw r24,r28
 727               	.LVL75:
 728 00d2 64E6      		ldi r22,lo8(100)
 729 00d4 70E0      		ldi r23,0
 730               	.LVL76:
 731 00d6 0E94 0000 		call __divmodhi4
 732               	.LVL77:
1375:stk500boot.c  **** 	}
 733               		.loc 1 1375 0
 734 00da 80E3      		ldi r24,lo8(48)
 735 00dc 860F      		add r24,r22
 736 00de 0E94 0000 		call sendchar
 737               	.LVL78:
 738               	.L40:
1378:stk500boot.c  **** 	{
 739               		.loc 1 1378 0
 740 00e2 CB30      		cpi r28,11
 741 00e4 D105      		cpc r29,__zero_reg__
 742 00e6 04F4      		brge .L41
1378:stk500boot.c  **** 	{
 743               		.loc 1 1378 0 is_stmt 0 discriminator 1
 744 00e8 0230      		cpi r16,2
 745 00ea 1105      		cpc r17,__zero_reg__
 746 00ec 04F0      		brlt .L42
 747               	.L41:
 748               	.LVL79:
1380:stk500boot.c  **** 		sendchar(theChar );
 749               		.loc 1 1380 0 is_stmt 1
 750 00ee CE01      		movw r24,r28
 751 00f0 64E6      		ldi r22,lo8(100)
 752 00f2 70E0      		ldi r23,0
 753 00f4 0E94 0000 		call __divmodhi4
 754 00f8 6AE0      		ldi r22,lo8(10)
 755 00fa 70E0      		ldi r23,0
 756 00fc 0E94 0000 		call __divmodhi4
1381:stk500boot.c  **** 	}
 757               		.loc 1 1381 0
 758 0100 80E3      		ldi r24,lo8(48)
 759 0102 860F      		add r24,r22
 760 0104 0E94 0000 		call sendchar
 761               	.LVL80:
 762               	.L42:
1383:stk500boot.c  **** 	sendchar(theChar );
 763               		.loc 1 1383 0
 764 0108 CE01      		movw r24,r28
 765 010a 6AE0      		ldi r22,lo8(10)
 766 010c 70E0      		ldi r23,0
 767 010e 0E94 0000 		call __divmodhi4
1384:stk500boot.c  **** }
 768               		.loc 1 1384 0
 769 0112 805D      		subi r24,lo8(-(48))
 770               	/* epilogue start */
1385:stk500boot.c  **** 
 771               		.loc 1 1385 0
 772 0114 DF91      		pop r29
 773 0116 CF91      		pop r28
 774               	.LVL81:
 775 0118 1F91      		pop r17
 776 011a 0F91      		pop r16
 777               	.LVL82:
1384:stk500boot.c  **** }
 778               		.loc 1 1384 0
 779 011c 0C94 0000 		jmp sendchar
 780               	.LVL83:
 781               		.cfi_endproc
 782               	.LFE23:
 784               		.section	.text.startup,"ax",@progbits
 785               	.global	main
 787               	main:
 788               	.LFB17:
 532:stk500boot.c  **** 	address_t		address			=	0;
 789               		.loc 1 532 0
 790               		.cfi_startproc
 791 0000 CF93      		push r28
 792               	.LCFI30:
 793               		.cfi_def_cfa_offset 4
 794               		.cfi_offset 28, -3
 795 0002 DF93      		push r29
 796               	.LCFI31:
 797               		.cfi_def_cfa_offset 5
 798               		.cfi_offset 29, -4
 799 0004 CDB7      		in r28,__SP_L__
 800 0006 DEB7      		in r29,__SP_H__
 801               	.LCFI32:
 802               		.cfi_def_cfa_register 28
 803 0008 C053      		subi r28,48
 804 000a D140      		sbci r29,1
 805               	.LCFI33:
 806               		.cfi_def_cfa_offset 309
 807 000c 0FB6      		in __tmp_reg__,__SREG__
 808 000e F894      		cli
 809 0010 DEBF      		out __SP_H__,r29
 810 0012 0FBE      		out __SREG__,__tmp_reg__
 811 0014 CDBF      		out __SP_L__,r28
 812               	/* prologue: function */
 813               	/* frame size = 304 */
 814               	/* stack size = 306 */
 815               	.L__stack_usage = 306
 816               	.LVL84:
 553:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 817               		.loc 1 553 0
 818               	/* #APP */
 819               	 ;  553 "stk500boot.c" 1
 820               		.set __stack, 8703
 821               	 ;  0 "" 2
 554:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 822               		.loc 1 554 0
 823               	 ;  554 "stk500boot.c" 1
 824 0016 01E2      		ldi	16, 33
 825               	 ;  0 "" 2
 555:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 826               		.loc 1 555 0
 827               	 ;  555 "stk500boot.c" 1
 828 0018 0EBF      		out 62,16
 829               	 ;  0 "" 2
 556:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 830               		.loc 1 556 0
 831               	 ;  556 "stk500boot.c" 1
 832 001a 0FEF      		ldi	16, 255
 833               	 ;  0 "" 2
 557:stk500boot.c  **** 
 834               		.loc 1 557 0
 835               	 ;  557 "stk500boot.c" 1
 836 001c 0DBF      		out 61,16
 837               	 ;  0 "" 2
 564:stk500boot.c  **** 
 838               		.loc 1 564 0
 839               	/* #NOAPP */
 840 001e 94B7      		in r25,0x34
 841               	.LVL85:
 566:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 842               		.loc 1 566 0
 843               	/* #APP */
 844               	 ;  566 "stk500boot.c" 1
 845 0020 F894      		cli
 846               	 ;  0 "" 2
 567:stk500boot.c  **** 	MCUSR	=	0;
 847               		.loc 1 567 0
 848               	 ;  567 "stk500boot.c" 1
 849 0022 A895      		wdr
 850               	 ;  0 "" 2
 568:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 851               		.loc 1 568 0
 852               	/* #NOAPP */
 853 0024 14BE      		out 0x34,__zero_reg__
 569:stk500boot.c  **** 	WDTCSR	=	0;
 854               		.loc 1 569 0
 855 0026 8091 6000 		lds r24,96
 856 002a 8861      		ori r24,lo8(24)
 857 002c 8093 6000 		sts 96,r24
 570:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 858               		.loc 1 570 0
 859 0030 1092 6000 		sts 96,__zero_reg__
 571:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 860               		.loc 1 571 0
 861               	/* #APP */
 862               	 ;  571 "stk500boot.c" 1
 863 0034 7894      		sei
 864               	 ;  0 "" 2
 573:stk500boot.c  **** 	{
 865               		.loc 1 573 0
 866               	/* #NOAPP */
 867 0036 93FF      		sbrs r25,3
 868 0038 00C0      		rjmp .L44
 575:stk500boot.c  **** 	}
 869               		.loc 1 575 0
 870 003a E091 0000 		lds r30,app_start
 871 003e F091 0000 		lds r31,app_start+1
 872 0042 1995      		eicall
 873               	.LVL86:
 874               	.L44:
 597:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 875               		.loc 1 597 0
 876 0044 279A      		sbi 0x4,7
 599:stk500boot.c  **** 
 877               		.loc 1 599 0
 878 0046 2F9A      		sbi 0x5,7
 617:stk500boot.c  **** #endif
 879               		.loc 1 617 0
 880 0048 8091 C000 		lds r24,192
 881 004c 8260      		ori r24,lo8(2)
 882 004e 8093 C000 		sts 192,r24
 619:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 883               		.loc 1 619 0
 884 0052 82E2      		ldi r24,lo8(34)
 885 0054 8093 C400 		sts 196,r24
 620:stk500boot.c  **** 
 886               		.loc 1 620 0
 887 0058 88E1      		ldi r24,lo8(24)
 888 005a 8093 C100 		sts 193,r24
 622:stk500boot.c  **** 
 889               		.loc 1 622 0
 890               	/* #APP */
 891               	 ;  622 "stk500boot.c" 1
 892 005e 0000      		nop
 893               	 ;  0 "" 2
 581:stk500boot.c  **** 	boot_state	=	0;
 894               		.loc 1 581 0
 895               	/* #NOAPP */
 896 0060 C12C      		mov r12,__zero_reg__
 897 0062 D12C      		mov r13,__zero_reg__
 898 0064 7601      		movw r14,r12
 652:stk500boot.c  **** 			{
 899               		.loc 1 652 0
 900 0066 A7EC      		ldi r26,lo8(-57)
 901 0068 8A2E      		mov r8,r26
 902 006a ABE1      		ldi r26,lo8(27)
 903 006c 9A2E      		mov r9,r26
 904 006e A12C      		mov r10,__zero_reg__
 905 0070 B12C      		mov r11,__zero_reg__
 906               	.LVL87:
 907               	.L45:
 532:stk500boot.c  **** 	address_t		address			=	0;
 908               		.loc 1 532 0
 909 0072 00E0      		ldi r16,0
 910 0074 10E0      		ldi r17,0
 911               	.LVL88:
 912               	.L52:
 913               	.LBB134:
 914               	.LBB135:
 477:stk500boot.c  **** }
 915               		.loc 1 477 0
 916 0076 8091 C000 		lds r24,192
 917               	.LBE135:
 918               	.LBE134:
 643:stk500boot.c  **** 		{
 919               		.loc 1 643 0
 920 007a 87FF      		sbrs r24,7
 921 007c 00C0      		rjmp .L48
 922               	.L51:
 659:stk500boot.c  **** 	}
 923               		.loc 1 659 0
 924 007e A801      		movw r20,r16
 925 0080 4F5F      		subi r20,-1
 926 0082 5F4F      		sbci r21,-1
 927               	.LVL89:
 641:stk500boot.c  **** 	{
 928               		.loc 1 641 0
 929 0084 01F0      		breq .L45
 930 0086 00C0      		rjmp .L282
 931               	.LVL90:
 932               	.L48:
 643:stk500boot.c  **** 		{
 933               		.loc 1 643 0 discriminator 1
 934 0088 0115      		cp r16,__zero_reg__
 935 008a 1105      		cpc r17,__zero_reg__
 936 008c 01F4      		brne .L51
 937               	.LVL91:
 938               	.LBB136:
 939               	.LBB137:
 940               		.loc 2 163 0
 941 008e 25E0      		ldi r18,lo8(5)
 942 0090 2A95      	1:	dec r18
 943 0092 01F4      		brne 1b
 944 0094 0000      		nop
 945               	.LVL92:
 946               	.LBE137:
 947               	.LBE136:
 646:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 948               		.loc 1 646 0
 949 0096 3FEF      		ldi r19,-1
 950 0098 C31A      		sub r12,r19
 951 009a D30A      		sbc r13,r19
 952 009c E30A      		sbc r14,r19
 953 009e F30A      		sbc r15,r19
 954               	.LVL93:
 647:stk500boot.c  **** 			{
 955               		.loc 1 647 0
 956 00a0 91E0      		ldi r25,lo8(1)
 957 00a2 80E0      		ldi r24,0
 958 00a4 41E2      		ldi r20,33
 959 00a6 C416      		cp r12,r20
 960 00a8 4EE4      		ldi r20,78
 961 00aa D406      		cpc r13,r20
 962 00ac E104      		cpc r14,__zero_reg__
 963 00ae F104      		cpc r15,__zero_reg__
 964 00b0 00F4      		brsh .L46
 965 00b2 90E0      		ldi r25,0
 966               	.L46:
 649:stk500boot.c  **** 			}
 967               		.loc 1 649 0
 968 00b4 092F      		mov r16,r25
 969               	.LVL94:
 970 00b6 182F      		mov r17,r24
 652:stk500boot.c  **** 			{
 971               		.loc 1 652 0
 972 00b8 C701      		movw r24,r14
 973 00ba B601      		movw r22,r12
 974 00bc A501      		movw r20,r10
 975 00be 9401      		movw r18,r8
 976 00c0 0E94 0000 		call __udivmodsi4
 977 00c4 672B      		or r22,r23
 978 00c6 682B      		or r22,r24
 979 00c8 692B      		or r22,r25
 980 00ca 01F4      		brne .L52
 655:stk500boot.c  **** 			}
 981               		.loc 1 655 0
 982 00cc 85B1      		in r24,0x5
 983 00ce 8058      		subi r24,lo8(-(-128))
 984 00d0 85B9      		out 0x5,r24
 985 00d2 00C0      		rjmp .L52
 986               	.LVL95:
 987               	.L282:
 663:stk500boot.c  **** 	{
 988               		.loc 1 663 0
 989 00d4 4130      		cpi r20,1
 990 00d6 5105      		cpc r21,__zero_reg__
 991 00d8 01F0      		breq .+4
 992 00da 0C94 0000 		jmp .L54
 993 00de C55D      		subi r28,lo8(-299)
 994 00e0 DE4F      		sbci r29,hi8(-299)
 995 00e2 1982      		std Y+1,__zero_reg__
 996 00e4 1882      		st Y,__zero_reg__
 997 00e6 CB52      		subi r28,lo8(299)
 998 00e8 D140      		sbci r29,hi8(299)
 999 00ea A12C      		mov r10,__zero_reg__
 1000 00ec B12C      		mov r11,__zero_reg__
 1001 00ee C65D      		subi r28,lo8(-298)
 1002 00f0 DE4F      		sbci r29,hi8(-298)
 1003 00f2 1882      		st Y,__zero_reg__
 1004 00f4 CA52      		subi r28,lo8(298)
 1005 00f6 D140      		sbci r29,hi8(298)
 1006 00f8 10E0      		ldi r17,0
 1007 00fa 212C      		mov r2,__zero_reg__
 1008 00fc 312C      		mov r3,__zero_reg__
 1009 00fe CA5D      		subi r28,lo8(-294)
 1010 0100 DE4F      		sbci r29,hi8(-294)
 1011 0102 1882      		st Y,__zero_reg__
 1012 0104 1982      		std Y+1,__zero_reg__
 1013 0106 1A82      		std Y+2,__zero_reg__
 1014 0108 1B82      		std Y+3,__zero_reg__
 1015 010a C652      		subi r28,lo8(294)
 1016 010c D140      		sbci r29,hi8(294)
 1017 010e C12C      		mov r12,__zero_reg__
 1018 0110 D12C      		mov r13,__zero_reg__
 1019 0112 7601      		movw r14,r12
 1020               	.LVL96:
 1021               	.L53:
 581:stk500boot.c  **** 	boot_state	=	0;
 1022               		.loc 1 581 0
 1023 0114 20E0      		ldi r18,0
 1024 0116 30E0      		ldi r19,0
 1025 0118 80E0      		ldi r24,0
 1026               	.LVL97:
 1027               	.L200:
 674:stk500boot.c  **** 				{
 1028               		.loc 1 674 0
 1029 011a 4130      		cpi r20,1
 1030 011c 5105      		cpc r21,__zero_reg__
 1031 011e 01F0      		breq .L271
 1032               	.LVL98:
 1033               	.L58:
 581:stk500boot.c  **** 	boot_state	=	0;
 1034               		.loc 1 581 0
 1035 0120 41E0      		ldi r20,lo8(1)
 1036 0122 52E1      		ldi r21,lo8(18)
 1037 0124 6AE7      		ldi r22,lo8(122)
 1038 0126 70E0      		ldi r23,0
 1039               	.L57:
 1040               	.LVL99:
 1041               	.LBB138:
 1042               	.LBB139:
 500:stk500boot.c  **** 	{
 1043               		.loc 1 500 0
 1044 0128 9091 C000 		lds r25,192
 1045 012c 97FD      		sbrc r25,7
 1046 012e 00C0      		rjmp .L271
 1047               	.LVL100:
 1048 0130 4150      		subi r20,1
 1049 0132 5109      		sbc r21,__zero_reg__
 1050 0134 6109      		sbc r22,__zero_reg__
 1051 0136 7109      		sbc r23,__zero_reg__
 1052               	.LVL101:
 504:stk500boot.c  **** 		{
 1053               		.loc 1 504 0
 1054 0138 01F4      		brne .L57
 1055               	.LVL102:
 1056               	.LBB140:
 1057               	.LBB141:
 508:stk500boot.c  **** 		#else
 1058               		.loc 1 508 0
 1059               	/* #APP */
 1060               	 ;  508 "stk500boot.c" 1
 1061 013a 6BBF      		out 59, r22
 1062 013c FA01      		movw r30, r20
 1063 013e 4791      		elpm r20, Z+
 1064 0140 5691      		elpm r21, Z
 1065               		
 1066               	 ;  0 "" 2
 1067               	.LVL103:
 1068               	/* #NOAPP */
 1069               	.LBE141:
 512:stk500boot.c  **** 			{
 1070               		.loc 1 512 0
 1071 0142 4F3F      		cpi r20,-1
 1072 0144 5F4F      		sbci r21,-1
 1073 0146 01F0      		breq .L58
 514:stk500boot.c  **** 						"clr	r30		\n\t"
 1074               		.loc 1 514 0
 1075               	/* #APP */
 1076               	 ;  514 "stk500boot.c" 1
 1077 0148 EE27      		clr	r30		
 1078 014a FF27      		clr	r31		
 1079 014c 0994      		ijmp	
 1080               		
 1081               	 ;  0 "" 2
 1082               	/* #NOAPP */
 1083 014e 00C0      		rjmp .L58
 1084               	.LVL104:
 1085               	.L271:
 1086               	.LBE140:
 523:stk500boot.c  **** }
 1087               		.loc 1 523 0
 1088 0150 9091 C600 		lds r25,198
 1089               	.LVL105:
 1090               	.LBE139:
 1091               	.LBE138:
 687:stk500boot.c  **** 
 1092               		.loc 1 687 0
 1093 0154 C55D      		subi r28,lo8(-299)
 1094 0156 DE4F      		sbci r29,hi8(-299)
 1095 0158 A881      		ld r26,Y
 1096 015a B981      		ldd r27,Y+1
 1097 015c CB52      		subi r28,lo8(299)
 1098 015e D140      		sbci r29,hi8(299)
 1099 0160 1196      		adiw r26,1
 1100 0162 C55D      		subi r28,lo8(-299)
 1101 0164 DE4F      		sbci r29,hi8(-299)
 1102 0166 B983      		std Y+1,r27
 1103 0168 A883      		st Y,r26
 1104 016a CB52      		subi r28,lo8(299)
 1105 016c D140      		sbci r29,hi8(299)
 1106               	.LVL106:
 689:stk500boot.c  **** 				{
 1107               		.loc 1 689 0
 1108 016e 9132      		cpi r25,lo8(33)
 1109 0170 01F0      		breq .+2
 1110 0172 00C0      		rjmp .L60
 689:stk500boot.c  **** 				{
 1111               		.loc 1 689 0 is_stmt 0 discriminator 1
 1112 0174 1A97      		sbiw r26,10
 1113 0176 00F0      		brlo .+2
 1114 0178 00C0      		rjmp .L206
 691:stk500boot.c  **** 					if (exPointCntr == 3)
 1115               		.loc 1 691 0 is_stmt 1
 1116 017a BFEF      		ldi r27,-1
 1117 017c AB1A      		sub r10,r27
 1118 017e BB0A      		sbc r11,r27
 1119               	.LVL107:
 692:stk500boot.c  **** 					{
 1120               		.loc 1 692 0
 1121 0180 E3E0      		ldi r30,3
 1122 0182 AE16      		cp r10,r30
 1123 0184 B104      		cpc r11,__zero_reg__
 1124 0186 01F0      		breq .+2
 1125 0188 00C0      		rjmp .L61
 1126 018a 05E0      		ldi r16,lo8(5)
 1127 018c 10E0      		ldi r17,0
 1128               	.LVL108:
 1129               	.L64:
 581:stk500boot.c  **** 	boot_state	=	0;
 1130               		.loc 1 581 0
 1131 018e F9E1      		ldi r31,lo8(25)
 1132 0190 AF2E      		mov r10,r31
 1133 0192 B12C      		mov r11,__zero_reg__
 1134               	.LVL109:
 1135               	.L63:
 1136               	.LBB142:
 1137               	.LBB143:
1753:stk500boot.c  **** 
1754:stk500boot.c  **** //************************************************************************
1755:stk500boot.c  **** static void	ListAvailablePorts(void)
1756:stk500boot.c  **** {
1757:stk500boot.c  **** 
1758:stk500boot.c  **** #ifdef DDRA
1759:stk500boot.c  **** 	PrintAvailablePort('A');
1760:stk500boot.c  **** #endif
1761:stk500boot.c  **** 
1762:stk500boot.c  **** #ifdef DDRB
1763:stk500boot.c  **** 	PrintAvailablePort('B');
1764:stk500boot.c  **** #endif
1765:stk500boot.c  **** 
1766:stk500boot.c  **** #ifdef DDRC
1767:stk500boot.c  **** 	PrintAvailablePort('C');
1768:stk500boot.c  **** #endif
1769:stk500boot.c  **** 
1770:stk500boot.c  **** #ifdef DDRD
1771:stk500boot.c  **** 	PrintAvailablePort('D');
1772:stk500boot.c  **** #endif
1773:stk500boot.c  **** 
1774:stk500boot.c  **** #ifdef DDRE
1775:stk500boot.c  **** 	PrintAvailablePort('E');
1776:stk500boot.c  **** #endif
1777:stk500boot.c  **** 
1778:stk500boot.c  **** #ifdef DDRF
1779:stk500boot.c  **** 	PrintAvailablePort('F');
1780:stk500boot.c  **** #endif
1781:stk500boot.c  **** 
1782:stk500boot.c  **** #ifdef DDRG
1783:stk500boot.c  **** 	PrintAvailablePort('G');
1784:stk500boot.c  **** #endif
1785:stk500boot.c  **** 
1786:stk500boot.c  **** #ifdef DDRH
1787:stk500boot.c  **** 	PrintAvailablePort('H');
1788:stk500boot.c  **** #endif
1789:stk500boot.c  **** 
1790:stk500boot.c  **** #ifdef DDRI
1791:stk500boot.c  **** 	PrintAvailablePort('I');
1792:stk500boot.c  **** #endif
1793:stk500boot.c  **** 
1794:stk500boot.c  **** #ifdef DDRJ
1795:stk500boot.c  **** 	PrintAvailablePort('J');
1796:stk500boot.c  **** #endif
1797:stk500boot.c  **** 
1798:stk500boot.c  **** #ifdef DDRK
1799:stk500boot.c  **** 	PrintAvailablePort('K');
1800:stk500boot.c  **** #endif
1801:stk500boot.c  **** 
1802:stk500boot.c  **** #ifdef DDRL
1803:stk500boot.c  **** 	PrintAvailablePort('L');
1804:stk500boot.c  **** #endif
1805:stk500boot.c  **** 
1806:stk500boot.c  **** }
1807:stk500boot.c  **** 
1808:stk500boot.c  **** //************************************************************************
1809:stk500boot.c  **** static void	AVR_PortOutput(void)
1810:stk500boot.c  **** {
1811:stk500boot.c  **** char	portLetter;
1812:stk500boot.c  **** char	getCharFlag;
1813:stk500boot.c  **** 
1814:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1815:stk500boot.c  **** 
1816:stk500boot.c  **** 	portLetter	=	recchar();
1817:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1818:stk500boot.c  **** 	sendchar(portLetter);
1819:stk500boot.c  **** 	PrintNewLine();
1820:stk500boot.c  **** 
1821:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1822:stk500boot.c  **** 	{
1823:stk500boot.c  **** 		getCharFlag	=	true;
1824:stk500boot.c  **** 		switch(portLetter)
1825:stk500boot.c  **** 		{
1826:stk500boot.c  **** 		#ifdef DDRA
1827:stk500boot.c  **** 			case 'A':
1828:stk500boot.c  **** 				DDRA	=	0xff;
1829:stk500boot.c  **** 				while (!Serial_Available())
1830:stk500boot.c  **** 				{
1831:stk500boot.c  **** 					PORTA	^=	0xff;
1832:stk500boot.c  **** 					delay_ms(200);
1833:stk500boot.c  **** 				}
1834:stk500boot.c  **** 				PORTA	=	0;
1835:stk500boot.c  **** 				break;
1836:stk500boot.c  **** 		#endif
1837:stk500boot.c  **** 
1838:stk500boot.c  **** 		#ifdef DDRB
1839:stk500boot.c  **** 			case 'B':
1840:stk500boot.c  **** 				DDRB	=	0xff;
1841:stk500boot.c  **** 				while (!Serial_Available())
1842:stk500boot.c  **** 				{
1843:stk500boot.c  **** 					PORTB	^=	0xff;
1844:stk500boot.c  **** 					delay_ms(200);
1845:stk500boot.c  **** 				}
1846:stk500boot.c  **** 				PORTB	=	0;
1847:stk500boot.c  **** 				break;
1848:stk500boot.c  **** 		#endif
1849:stk500boot.c  **** 
1850:stk500boot.c  **** 		#ifdef DDRC
1851:stk500boot.c  **** 			case 'C':
1852:stk500boot.c  **** 				DDRC	=	0xff;
1853:stk500boot.c  **** 				while (!Serial_Available())
1854:stk500boot.c  **** 				{
1855:stk500boot.c  **** 					PORTC	^=	0xff;
1856:stk500boot.c  **** 					delay_ms(200);
1857:stk500boot.c  **** 				}
1858:stk500boot.c  **** 				PORTC	=	0;
1859:stk500boot.c  **** 				break;
1860:stk500boot.c  **** 		#endif
1861:stk500boot.c  **** 
1862:stk500boot.c  **** 		#ifdef DDRD
1863:stk500boot.c  **** 			case 'D':
1864:stk500boot.c  **** 				DDRD	=	0xff;
1865:stk500boot.c  **** 				while (!Serial_Available())
1866:stk500boot.c  **** 				{
1867:stk500boot.c  **** 					PORTD	^=	0xff;
1868:stk500boot.c  **** 					delay_ms(200);
1869:stk500boot.c  **** 				}
1870:stk500boot.c  **** 				PORTD	=	0;
1871:stk500boot.c  **** 				break;
1872:stk500boot.c  **** 		#endif
1873:stk500boot.c  **** 
1874:stk500boot.c  **** 		#ifdef DDRE
1875:stk500boot.c  **** 			case 'E':
1876:stk500boot.c  **** 				DDRE	=	0xff;
1877:stk500boot.c  **** 				while (!Serial_Available())
1878:stk500boot.c  **** 				{
1879:stk500boot.c  **** 					PORTE	^=	0xff;
1880:stk500boot.c  **** 					delay_ms(200);
1881:stk500boot.c  **** 				}
1882:stk500boot.c  **** 				PORTE	=	0;
1883:stk500boot.c  **** 				break;
1884:stk500boot.c  **** 		#endif
1885:stk500boot.c  **** 
1886:stk500boot.c  **** 		#ifdef DDRF
1887:stk500boot.c  **** 			case 'F':
1888:stk500boot.c  **** 				DDRF	=	0xff;
1889:stk500boot.c  **** 				while (!Serial_Available())
1890:stk500boot.c  **** 				{
1891:stk500boot.c  **** 					PORTF	^=	0xff;
1892:stk500boot.c  **** 					delay_ms(200);
1893:stk500boot.c  **** 				}
1894:stk500boot.c  **** 				PORTF	=	0;
1895:stk500boot.c  **** 				break;
1896:stk500boot.c  **** 		#endif
1897:stk500boot.c  **** 
1898:stk500boot.c  **** 		#ifdef DDRG
1899:stk500boot.c  **** 			case 'G':
1900:stk500boot.c  **** 				DDRG	=	0xff;
1901:stk500boot.c  **** 				while (!Serial_Available())
1902:stk500boot.c  **** 				{
1903:stk500boot.c  **** 					PORTG	^=	0xff;
1904:stk500boot.c  **** 					delay_ms(200);
1905:stk500boot.c  **** 				}
1906:stk500boot.c  **** 				PORTG	=	0;
1907:stk500boot.c  **** 				break;
1908:stk500boot.c  **** 		#endif
1909:stk500boot.c  **** 
1910:stk500boot.c  **** 		#ifdef DDRH
1911:stk500boot.c  **** 			case 'H':
1912:stk500boot.c  **** 				DDRH	=	0xff;
1913:stk500boot.c  **** 				while (!Serial_Available())
1914:stk500boot.c  **** 				{
1915:stk500boot.c  **** 					PORTH	^=	0xff;
1916:stk500boot.c  **** 					delay_ms(200);
1917:stk500boot.c  **** 				}
1918:stk500boot.c  **** 				PORTH	=	0;
1919:stk500boot.c  **** 				break;
1920:stk500boot.c  **** 		#endif
1921:stk500boot.c  **** 
1922:stk500boot.c  **** 		#ifdef DDRI
1923:stk500boot.c  **** 			case 'I':
1924:stk500boot.c  **** 				DDRI	=	0xff;
1925:stk500boot.c  **** 				while (!Serial_Available())
1926:stk500boot.c  **** 				{
1927:stk500boot.c  **** 					PORTI	^=	0xff;
1928:stk500boot.c  **** 					delay_ms(200);
1929:stk500boot.c  **** 				}
1930:stk500boot.c  **** 				PORTI	=	0;
1931:stk500boot.c  **** 				break;
1932:stk500boot.c  **** 		#endif
1933:stk500boot.c  **** 
1934:stk500boot.c  **** 		#ifdef DDRJ
1935:stk500boot.c  **** 			case 'J':
1936:stk500boot.c  **** 				DDRJ	=	0xff;
1937:stk500boot.c  **** 				while (!Serial_Available())
1938:stk500boot.c  **** 				{
1939:stk500boot.c  **** 					PORTJ	^=	0xff;
1940:stk500boot.c  **** 					delay_ms(200);
1941:stk500boot.c  **** 				}
1942:stk500boot.c  **** 				PORTJ	=	0;
1943:stk500boot.c  **** 				break;
1944:stk500boot.c  **** 		#endif
1945:stk500boot.c  **** 
1946:stk500boot.c  **** 		#ifdef DDRK
1947:stk500boot.c  **** 			case 'K':
1948:stk500boot.c  **** 				DDRK	=	0xff;
1949:stk500boot.c  **** 				while (!Serial_Available())
1950:stk500boot.c  **** 				{
1951:stk500boot.c  **** 					PORTK	^=	0xff;
1952:stk500boot.c  **** 					delay_ms(200);
1953:stk500boot.c  **** 				}
1954:stk500boot.c  **** 				PORTK	=	0;
1955:stk500boot.c  **** 				break;
1956:stk500boot.c  **** 		#endif
1957:stk500boot.c  **** 
1958:stk500boot.c  **** 		#ifdef DDRL
1959:stk500boot.c  **** 			case 'L':
1960:stk500boot.c  **** 				DDRL	=	0xff;
1961:stk500boot.c  **** 				while (!Serial_Available())
1962:stk500boot.c  **** 				{
1963:stk500boot.c  **** 					PORTL	^=	0xff;
1964:stk500boot.c  **** 					delay_ms(200);
1965:stk500boot.c  **** 				}
1966:stk500boot.c  **** 				PORTL	=	0;
1967:stk500boot.c  **** 				break;
1968:stk500boot.c  **** 		#endif
1969:stk500boot.c  **** 
1970:stk500boot.c  **** 			default:
1971:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
1972:stk500boot.c  **** 				getCharFlag	=	false;
1973:stk500boot.c  **** 				break;
1974:stk500boot.c  **** 		}
1975:stk500boot.c  **** 		if (getCharFlag)
1976:stk500boot.c  **** 		{
1977:stk500boot.c  **** 			recchar();
1978:stk500boot.c  **** 		}
1979:stk500boot.c  **** 	}
1980:stk500boot.c  **** 	else
1981:stk500boot.c  **** 	{
1982:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
1983:stk500boot.c  **** 	}
1984:stk500boot.c  **** }
1985:stk500boot.c  **** 
1986:stk500boot.c  **** 
1987:stk500boot.c  **** //*******************************************************************
1988:stk500boot.c  **** static void PrintHelp(void)
1989:stk500boot.c  **** {
1990:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
1991:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
1992:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
1993:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
1994:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
1995:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
1996:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
1997:stk500boot.c  **** 
1998:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
1999:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2000:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2002:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2003:stk500boot.c  **** }
2004:stk500boot.c  **** 
2005:stk500boot.c  **** //************************************************************************
2006:stk500boot.c  **** static void	RunMonitor(void)
2007:stk500boot.c  **** {
2008:stk500boot.c  **** char			keepGoing;
2009:stk500boot.c  **** unsigned char	theChar;
2010:stk500boot.c  **** int				ii, jj;
2011:stk500boot.c  **** 
2012:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2013:stk500boot.c  **** 	{
2014:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2015:stk500boot.c  **** 		{
2016:stk500boot.c  **** 			sendchar('!');
 1138               		.loc 1 2016 0
 1139 0194 81E2      		ldi r24,lo8(33)
 1140 0196 0E94 0000 		call sendchar
 1141               	.LVL110:
 1142 019a F1E0      		ldi r31,1
 1143 019c AF1A      		sub r10,r31
 1144 019e B108      		sbc r11,__zero_reg__
 1145               	.LVL111:
2014:stk500boot.c  **** 		{
 1146               		.loc 1 2014 0
 1147 01a0 01F4      		brne .L63
2017:stk500boot.c  **** 		}
2018:stk500boot.c  **** 		PrintNewLine();
 1148               		.loc 1 2018 0
 1149 01a2 0E94 0000 		call PrintNewLine
 1150               	.LVL112:
 1151 01a6 0150      		subi r16,1
 1152 01a8 1109      		sbc r17,__zero_reg__
 1153               	.LVL113:
2012:stk500boot.c  **** 	{
 1154               		.loc 1 2012 0
 1155 01aa 01F4      		brne .L64
2019:stk500boot.c  **** 	}
2020:stk500boot.c  **** 
2021:stk500boot.c  **** 	gRamIndex			=	0;
 1156               		.loc 1 2021 0
 1157 01ac 1092 0000 		sts gRamIndex,__zero_reg__
 1158 01b0 1092 0000 		sts gRamIndex+1,__zero_reg__
 1159 01b4 1092 0000 		sts gRamIndex+2,__zero_reg__
 1160 01b8 1092 0000 		sts gRamIndex+3,__zero_reg__
2022:stk500boot.c  **** 	gFlashIndex			=	0;
 1161               		.loc 1 2022 0
 1162 01bc 1092 0000 		sts gFlashIndex,__zero_reg__
 1163 01c0 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1164 01c4 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1165 01c8 1092 0000 		sts gFlashIndex+3,__zero_reg__
2023:stk500boot.c  **** 	gEepromIndex		=	0;
 1166               		.loc 1 2023 0
 1167 01cc 1092 0000 		sts gEepromIndex,__zero_reg__
 1168 01d0 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1169 01d4 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1170 01d8 1092 0000 		sts gEepromIndex+3,__zero_reg__
2024:stk500boot.c  **** 
2025:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1171               		.loc 1 2025 0
 1172 01dc 60E0      		ldi r22,0
 1173 01de 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1174 01e0 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1175 01e2 0E94 0000 		call PrintFromPROGMEMln
 1176               	.LVL114:
 1177               	.LBB144:
 1178               	.LBB145:
1888:stk500boot.c  **** 				while (!Serial_Available())
 1179               		.loc 1 1888 0
 1180 01e6 1FEF      		ldi r17,lo8(-1)
 1181               	.LVL115:
 1182               	.L202:
 1183               	.LBE145:
 1184               	.LBE144:
2026:stk500boot.c  **** 
2027:stk500boot.c  **** 	keepGoing	=	1;
2028:stk500boot.c  **** 	while (keepGoing)
2029:stk500boot.c  **** 	{
2030:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
 1185               		.loc 1 2030 0
 1186 01e8 60E0      		ldi r22,0
 1187 01ea 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1188 01ec 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1189 01ee 0E94 0000 		call PrintFromPROGMEM
 1190               	.LVL116:
2031:stk500boot.c  **** 		theChar	=	recchar();
 1191               		.loc 1 2031 0
 1192 01f2 0E94 0000 		call recchar
 1193               	.LVL117:
 1194 01f6 082F      		mov r16,r24
 1195               	.LVL118:
2032:stk500boot.c  **** 		if (theChar >= 0x60)
 1196               		.loc 1 2032 0
 1197 01f8 8036      		cpi r24,lo8(96)
 1198 01fa 00F0      		brlo .L66
2033:stk500boot.c  **** 		{
2034:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1199               		.loc 1 2034 0
 1200 01fc 0F75      		andi r16,lo8(95)
 1201               	.LVL119:
 1202               	.L66:
2035:stk500boot.c  **** 		}
2036:stk500boot.c  **** 
2037:stk500boot.c  **** 		if (theChar >= 0x20)
 1203               		.loc 1 2037 0
 1204 01fe 0032      		cpi r16,lo8(32)
 1205 0200 00F0      		brlo .L67
2038:stk500boot.c  **** 		{
2039:stk500boot.c  **** 			sendchar(theChar);
 1206               		.loc 1 2039 0
 1207 0202 802F      		mov r24,r16
 1208 0204 0E94 0000 		call sendchar
 1209               	.LVL120:
2040:stk500boot.c  **** 			sendchar(0x20);
 1210               		.loc 1 2040 0
 1211 0208 80E2      		ldi r24,lo8(32)
 1212 020a 0E94 0000 		call sendchar
 1213               	.LVL121:
 1214               	.L67:
2041:stk500boot.c  **** 		}
2042:stk500boot.c  **** 
2043:stk500boot.c  **** 		switch(theChar)
 1215               		.loc 1 2043 0
 1216 020e 0634      		cpi r16,lo8(70)
 1217 0210 01F4      		brne .+2
 1218 0212 00C0      		rjmp .L69
 1219 0214 00F0      		brlo .+2
 1220 0216 00C0      		rjmp .L70
 1221 0218 0034      		cpi r16,lo8(64)
 1222 021a 01F4      		brne .+2
 1223 021c 00C0      		rjmp .L71
 1224 021e 00F0      		brlo .+2
 1225 0220 00C0      		rjmp .L72
 1226 0222 0033      		cpi r16,lo8(48)
 1227 0224 01F4      		brne .+2
 1228 0226 00C0      		rjmp .L73
 1229 0228 0F33      		cpi r16,lo8(63)
 1230 022a 01F0      		breq .+2
 1231 022c 00C0      		rjmp .L68
2044:stk500boot.c  **** 		{
2045:stk500boot.c  **** 			case '0':
2046:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2047:stk500boot.c  **** 				gFlashIndex		=	0;
2048:stk500boot.c  **** 				gRamIndex		=	0;
2049:stk500boot.c  **** 				gEepromIndex	=	0;
2050:stk500boot.c  **** 				break;
2051:stk500boot.c  **** 
2052:stk500boot.c  **** 			case '?':
2053:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
 1232               		.loc 1 2053 0
 1233 022e 62E0      		ldi r22,lo8(2)
 1234 0230 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1235 0232 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1236 0234 0E94 0000 		call PrintFromPROGMEMln
 1237               	.LVL122:
 1238               	.LBB170:
 1239               	.LBB171:
1395:stk500boot.c  **** 
 1240               		.loc 1 1395 0
 1241 0238 60E0      		ldi r22,0
 1242 023a 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1243 023c 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1244 023e 0E94 0000 		call PrintFromPROGMEMln
 1245               	.LVL123:
1397:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1246               		.loc 1 1397 0
 1247 0242 60E0      		ldi r22,0
 1248 0244 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1249 0246 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1250 0248 0E94 0000 		call PrintFromPROGMEM
 1251               	.LVL124:
1398:stk500boot.c  **** 
 1252               		.loc 1 1398 0
 1253 024c 60E0      		ldi r22,0
 1254 024e 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1255 0250 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1256 0252 0E94 0000 		call PrintFromPROGMEMln
 1257               	.LVL125:
1400:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1258               		.loc 1 1400 0
 1259 0256 60E0      		ldi r22,0
 1260 0258 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1261 025a 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1262 025c 0E94 0000 		call PrintFromPROGMEM
 1263               	.LVL126:
1401:stk500boot.c  **** 
 1264               		.loc 1 1401 0
 1265 0260 60E0      		ldi r22,0
 1266 0262 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1267 0264 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1268 0266 0E94 0000 		call PrintFromPROGMEMln
 1269               	.LVL127:
1403:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1270               		.loc 1 1403 0
 1271 026a 60E0      		ldi r22,0
 1272 026c 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1273 026e 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1274 0270 0E94 0000 		call PrintFromPROGMEM
 1275               	.LVL128:
 1276               	.LBB172:
 1277               	.LBB173:
1384:stk500boot.c  **** }
 1278               		.loc 1 1384 0
 1279 0274 86E3      		ldi r24,lo8(54)
 1280 0276 0E94 0000 		call sendchar
 1281               	.LVL129:
 1282               	.LBE173:
 1283               	.LBE172:
1405:stk500boot.c  **** 
 1284               		.loc 1 1405 0
 1285 027a 0E94 0000 		call PrintNewLine
 1286               	.LVL130:
1407:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1287               		.loc 1 1407 0
 1288 027e 60E0      		ldi r22,0
 1289 0280 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1290 0282 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1291 0284 0E94 0000 		call PrintFromPROGMEM
 1292               	.LVL131:
1408:stk500boot.c  **** 
 1293               		.loc 1 1408 0
 1294 0288 60E0      		ldi r22,0
 1295 028a 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1296 028c 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1297 028e 0E94 0000 		call PrintFromPROGMEMln
 1298               	.LVL132:
1411:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1299               		.loc 1 1411 0
 1300 0292 60E0      		ldi r22,0
 1301 0294 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1302 0296 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1303 0298 0E94 0000 		call PrintFromPROGMEM
 1304               	.LVL133:
1412:stk500boot.c  **** 
 1305               		.loc 1 1412 0
 1306 029c 60E0      		ldi r22,0
 1307 029e 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1308 02a0 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1309 02a2 0E94 0000 		call PrintFromPROGMEMln
 1310               	.LVL134:
1415:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1311               		.loc 1 1415 0
 1312 02a6 60E0      		ldi r22,0
 1313 02a8 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1314 02aa 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1315 02ac 0E94 0000 		call PrintFromPROGMEM
 1316               	.LVL135:
1417:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1317               		.loc 1 1417 0
 1318 02b0 8EE1      		ldi r24,lo8(30)
 1319 02b2 0E94 0000 		call PrintHexByte
 1320               	.LVL136:
1418:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1321               		.loc 1 1418 0
 1322 02b6 88E9      		ldi r24,lo8(-104)
 1323 02b8 0E94 0000 		call PrintHexByte
 1324               	.LVL137:
1419:stk500boot.c  **** 	PrintNewLine();
 1325               		.loc 1 1419 0
 1326 02bc 81E0      		ldi r24,lo8(1)
 1327 02be 0E94 0000 		call PrintHexByte
 1328               	.LVL138:
1420:stk500boot.c  **** #endif
 1329               		.loc 1 1420 0
 1330 02c2 0E94 0000 		call PrintNewLine
 1331               	.LVL139:
1426:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1332               		.loc 1 1426 0
 1333 02c6 60E0      		ldi r22,0
 1334 02c8 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1335 02ca 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1336 02cc 0E94 0000 		call PrintFromPROGMEM
 1337               	.LVL140:
 1338               	.LBB174:
1427:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1339               		.loc 1 1427 0
 1340 02d0 29E0      		ldi r18,lo8(9)
 1341 02d2 E0E0      		ldi r30,0
 1342 02d4 F0E0      		ldi r31,0
 1343               	/* #APP */
 1344               	 ;  1427 "stk500boot.c" 1
 1345 02d6 2093 5700 		sts 87, r18
 1346 02da 8491      		lpm r24, Z
 1347               		
 1348               	 ;  0 "" 2
 1349               	.LVL141:
 1350               	/* #NOAPP */
 1351               	.LBE174:
1428:stk500boot.c  **** 	PrintNewLine();
 1352               		.loc 1 1428 0
 1353 02dc 0E94 0000 		call PrintHexByte
 1354               	.LVL142:
1429:stk500boot.c  **** 
 1355               		.loc 1 1429 0
 1356 02e0 0E94 0000 		call PrintNewLine
 1357               	.LVL143:
1431:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1358               		.loc 1 1431 0
 1359 02e4 60E0      		ldi r22,0
 1360 02e6 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1361 02e8 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1362 02ea 0E94 0000 		call PrintFromPROGMEM
 1363               	.LVL144:
 1364               	.LBB175:
1432:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1365               		.loc 1 1432 0
 1366 02ee 29E0      		ldi r18,lo8(9)
 1367 02f0 E3E0      		ldi r30,lo8(3)
 1368 02f2 F0E0      		ldi r31,0
 1369               	/* #APP */
 1370               	 ;  1432 "stk500boot.c" 1
 1371 02f4 2093 5700 		sts 87, r18
 1372 02f8 8491      		lpm r24, Z
 1373               		
 1374               	 ;  0 "" 2
 1375               	.LVL145:
 1376               	/* #NOAPP */
 1377               	.LBE175:
1433:stk500boot.c  **** 	PrintNewLine();
 1378               		.loc 1 1433 0
 1379 02fa 0E94 0000 		call PrintHexByte
 1380               	.LVL146:
1434:stk500boot.c  **** 
 1381               		.loc 1 1434 0
 1382 02fe 0E94 0000 		call PrintNewLine
 1383               	.LVL147:
1436:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1384               		.loc 1 1436 0
 1385 0302 60E0      		ldi r22,0
 1386 0304 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1387 0306 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1388 0308 0E94 0000 		call PrintFromPROGMEM
 1389               	.LVL148:
 1390               	.LBB176:
1437:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1391               		.loc 1 1437 0
 1392 030c E2E0      		ldi r30,lo8(2)
 1393 030e F0E0      		ldi r31,0
 1394 0310 39E0      		ldi r19,lo8(9)
 1395               	/* #APP */
 1396               	 ;  1437 "stk500boot.c" 1
 1397 0312 3093 5700 		sts 87, r19
 1398 0316 8491      		lpm r24, Z
 1399               		
 1400               	 ;  0 "" 2
 1401               	.LVL149:
 1402               	/* #NOAPP */
 1403               	.LBE176:
1438:stk500boot.c  **** 	PrintNewLine();
 1404               		.loc 1 1438 0
 1405 0318 0E94 0000 		call PrintHexByte
 1406               	.LVL150:
1439:stk500boot.c  **** 
 1407               		.loc 1 1439 0
 1408 031c 0E94 0000 		call PrintNewLine
 1409               	.LVL151:
1441:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1410               		.loc 1 1441 0
 1411 0320 60E0      		ldi r22,0
 1412 0322 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1413 0324 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1414 0326 0E94 0000 		call PrintFromPROGMEM
 1415               	.LVL152:
 1416               	.LBB177:
1442:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1417               		.loc 1 1442 0
 1418 032a E1E0      		ldi r30,lo8(1)
 1419 032c F0E0      		ldi r31,0
 1420 032e 49E0      		ldi r20,lo8(9)
 1421               	/* #APP */
 1422               	 ;  1442 "stk500boot.c" 1
 1423 0330 4093 5700 		sts 87, r20
 1424 0334 8491      		lpm r24, Z
 1425               		
 1426               	 ;  0 "" 2
 1427               	.LVL153:
 1428               	/* #NOAPP */
 1429               	.LBE177:
1443:stk500boot.c  **** 	PrintNewLine();
 1430               		.loc 1 1443 0
 1431 0336 0E94 0000 		call PrintHexByte
 1432               	.LVL154:
1444:stk500boot.c  **** 
 1433               		.loc 1 1444 0
 1434 033a 0E94 0000 		call PrintNewLine
 1435               	.LVL155:
 1436 033e 00C0      		rjmp .L202
 1437               	.LVL156:
 1438               	.L72:
 1439               	.LBE171:
 1440               	.LBE170:
2043:stk500boot.c  **** 		{
 1441               		.loc 1 2043 0
 1442 0340 0234      		cpi r16,lo8(66)
 1443 0342 01F4      		brne .+2
 1444 0344 00C0      		rjmp .L75
 1445 0346 0534      		cpi r16,lo8(69)
 1446 0348 01F4      		brne .+2
 1447 034a 00C0      		rjmp .L76
 1448 034c 00C0      		rjmp .L68
 1449               	.L70:
 1450 034e 0135      		cpi r16,lo8(81)
 1451 0350 01F4      		brne .+2
 1452 0352 00C0      		rjmp .L77
 1453 0354 00F4      		brsh .L78
 1454 0356 0834      		cpi r16,lo8(72)
 1455 0358 01F4      		brne .+2
 1456 035a 00C0      		rjmp .L79
 1457 035c 0C34      		cpi r16,lo8(76)
 1458 035e 01F0      		breq .+2
 1459 0360 00C0      		rjmp .L68
2054:stk500boot.c  **** 				PrintCPUstats();
2055:stk500boot.c  **** 				break;
2056:stk500boot.c  **** 
2057:stk500boot.c  **** 			case '@':
2058:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2059:stk500boot.c  **** 				EEPROMtest();
2060:stk500boot.c  **** 				break;
2061:stk500boot.c  **** 
2062:stk500boot.c  **** 			case 'B':
2063:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2064:stk500boot.c  **** 				BlinkLED();
2065:stk500boot.c  **** 				break;
2066:stk500boot.c  **** 
2067:stk500boot.c  **** 			case 'E':
2068:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
2069:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
2070:stk500boot.c  **** 				gEepromIndex	+=	256;
2071:stk500boot.c  **** 				if (gEepromIndex > E2END)
2072:stk500boot.c  **** 				{
2073:stk500boot.c  **** 					gEepromIndex	=	0;
2074:stk500boot.c  **** 				}
2075:stk500boot.c  **** 				break;
2076:stk500boot.c  **** 		
2077:stk500boot.c  **** 			case 'F':
2078:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2079:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2080:stk500boot.c  **** 				gFlashIndex	+=	256;
2081:stk500boot.c  **** 				break;
2082:stk500boot.c  **** 
2083:stk500boot.c  **** 			case 'H':
2084:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2085:stk500boot.c  **** 				PrintHelp();
2086:stk500boot.c  **** 				break;
2087:stk500boot.c  **** 
2088:stk500boot.c  **** 			case 'L':
2089:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1460               		.loc 1 2089 0
 1461 0362 62E0      		ldi r22,lo8(2)
 1462 0364 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1463 0366 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1464 0368 0E94 0000 		call PrintFromPROGMEMln
 1465               	.LVL157:
 1466               	.LBB178:
 1467               	.LBB179:
1759:stk500boot.c  **** #endif
 1468               		.loc 1 1759 0
 1469 036c 81E4      		ldi r24,lo8(65)
 1470 036e 0E94 0000 		call PrintAvailablePort
 1471               	.LVL158:
1763:stk500boot.c  **** #endif
 1472               		.loc 1 1763 0
 1473 0372 82E4      		ldi r24,lo8(66)
 1474 0374 0E94 0000 		call PrintAvailablePort
 1475               	.LVL159:
1767:stk500boot.c  **** #endif
 1476               		.loc 1 1767 0
 1477 0378 83E4      		ldi r24,lo8(67)
 1478 037a 0E94 0000 		call PrintAvailablePort
 1479               	.LVL160:
1771:stk500boot.c  **** #endif
 1480               		.loc 1 1771 0
 1481 037e 84E4      		ldi r24,lo8(68)
 1482 0380 0E94 0000 		call PrintAvailablePort
 1483               	.LVL161:
1775:stk500boot.c  **** #endif
 1484               		.loc 1 1775 0
 1485 0384 85E4      		ldi r24,lo8(69)
 1486 0386 0E94 0000 		call PrintAvailablePort
 1487               	.LVL162:
1779:stk500boot.c  **** #endif
 1488               		.loc 1 1779 0
 1489 038a 86E4      		ldi r24,lo8(70)
 1490 038c 0E94 0000 		call PrintAvailablePort
 1491               	.LVL163:
1783:stk500boot.c  **** #endif
 1492               		.loc 1 1783 0
 1493 0390 87E4      		ldi r24,lo8(71)
 1494 0392 0E94 0000 		call PrintAvailablePort
 1495               	.LVL164:
1787:stk500boot.c  **** #endif
 1496               		.loc 1 1787 0
 1497 0396 88E4      		ldi r24,lo8(72)
 1498 0398 0E94 0000 		call PrintAvailablePort
 1499               	.LVL165:
1795:stk500boot.c  **** #endif
 1500               		.loc 1 1795 0
 1501 039c 8AE4      		ldi r24,lo8(74)
 1502 039e 0E94 0000 		call PrintAvailablePort
 1503               	.LVL166:
1799:stk500boot.c  **** #endif
 1504               		.loc 1 1799 0
 1505 03a2 8BE4      		ldi r24,lo8(75)
 1506 03a4 0E94 0000 		call PrintAvailablePort
 1507               	.LVL167:
1803:stk500boot.c  **** #endif
 1508               		.loc 1 1803 0
 1509 03a8 8CE4      		ldi r24,lo8(76)
 1510 03aa 0E94 0000 		call PrintAvailablePort
 1511               	.LVL168:
 1512 03ae 00C0      		rjmp .L202
 1513               	.L78:
 1514               	.LBE179:
 1515               	.LBE178:
2043:stk500boot.c  **** 		{
 1516               		.loc 1 2043 0
 1517 03b0 0635      		cpi r16,lo8(86)
 1518 03b2 01F4      		brne .+2
 1519 03b4 00C0      		rjmp .L81
 1520 03b6 0935      		cpi r16,lo8(89)
 1521 03b8 01F4      		brne .+2
 1522 03ba 00C0      		rjmp .L82
 1523 03bc 0235      		cpi r16,lo8(82)
 1524 03be 01F0      		breq .+2
 1525 03c0 00C0      		rjmp .L68
2090:stk500boot.c  **** 				ListAvailablePorts();
2091:stk500boot.c  **** 				break;
2092:stk500boot.c  **** 
2093:stk500boot.c  **** 			case 'Q':
2094:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2095:stk500boot.c  **** 				keepGoing	=	false;
2096:stk500boot.c  **** 				break;
2097:stk500boot.c  **** 
2098:stk500boot.c  **** 			case 'R':
2099:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1526               		.loc 1 2099 0
 1527 03c2 62E0      		ldi r22,lo8(2)
 1528 03c4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1529 03c6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1530 03c8 0E94 0000 		call PrintFromPROGMEMln
 1531               	.LVL169:
2100:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1532               		.loc 1 2100 0
 1533 03cc 4091 0000 		lds r20,gRamIndex
 1534 03d0 5091 0000 		lds r21,gRamIndex+1
 1535 03d4 6091 0000 		lds r22,gRamIndex+2
 1536 03d8 7091 0000 		lds r23,gRamIndex+3
 1537 03dc 82E0      		ldi r24,lo8(2)
 1538 03de 0E94 0000 		call DumpHex.constprop.0
 1539               	.LVL170:
2101:stk500boot.c  **** 				gRamIndex	+=	256;
 1540               		.loc 1 2101 0
 1541 03e2 8091 0000 		lds r24,gRamIndex
 1542 03e6 9091 0000 		lds r25,gRamIndex+1
 1543 03ea A091 0000 		lds r26,gRamIndex+2
 1544 03ee B091 0000 		lds r27,gRamIndex+3
 1545 03f2 9F5F      		subi r25,-1
 1546 03f4 AF4F      		sbci r26,-1
 1547 03f6 BF4F      		sbci r27,-1
 1548 03f8 8093 0000 		sts gRamIndex,r24
 1549 03fc 9093 0000 		sts gRamIndex+1,r25
 1550 0400 A093 0000 		sts gRamIndex+2,r26
 1551 0404 B093 0000 		sts gRamIndex+3,r27
 1552 0408 00C0      		rjmp .L202
 1553               	.L73:
2046:stk500boot.c  **** 				gFlashIndex		=	0;
 1554               		.loc 1 2046 0
 1555 040a 62E0      		ldi r22,lo8(2)
 1556 040c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1557 040e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1558 0410 0E94 0000 		call PrintFromPROGMEMln
 1559               	.LVL171:
2047:stk500boot.c  **** 				gRamIndex		=	0;
 1560               		.loc 1 2047 0
 1561 0414 1092 0000 		sts gFlashIndex,__zero_reg__
 1562 0418 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1563 041c 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1564 0420 1092 0000 		sts gFlashIndex+3,__zero_reg__
2048:stk500boot.c  **** 				gEepromIndex	=	0;
 1565               		.loc 1 2048 0
 1566 0424 1092 0000 		sts gRamIndex,__zero_reg__
 1567 0428 1092 0000 		sts gRamIndex+1,__zero_reg__
 1568 042c 1092 0000 		sts gRamIndex+2,__zero_reg__
 1569 0430 1092 0000 		sts gRamIndex+3,__zero_reg__
 1570 0434 00C0      		rjmp .L273
 1571               	.L71:
2058:stk500boot.c  **** 				EEPROMtest();
 1572               		.loc 1 2058 0
 1573 0436 62E0      		ldi r22,lo8(2)
 1574 0438 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1575 043a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1576 043c 0E94 0000 		call PrintFromPROGMEMln
 1577               	.LVL172:
 1578               	.LBB180:
 1579               	.LBB181:
1553:stk500boot.c  **** 	PrintNewLine();
 1580               		.loc 1 1553 0
 1581 0440 60E0      		ldi r22,0
 1582 0442 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1583 0444 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1584 0446 0E94 0000 		call PrintFromPROGMEMln
 1585               	.LVL173:
1554:stk500boot.c  **** 	ii			=	0;
 1586               		.loc 1 1554 0
 1587 044a 0E94 0000 		call PrintNewLine
 1588               	.LVL174:
1555:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1589               		.loc 1 1555 0
 1590 044e A12C      		mov r10,__zero_reg__
 1591 0450 B12C      		mov r11,__zero_reg__
 1592               	.LVL175:
 1593               	.L85:
 1594 0452 C501      		movw r24,r10
 1595 0454 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1596 0456 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1597               	.LBB182:
1557:stk500boot.c  **** #else
 1598               		.loc 1 1557 0
 1599 0458 A0E0      		ldi r26,0
 1600 045a B0E0      		ldi r27,0
 1601               	/* #APP */
 1602               	 ;  1557 "stk500boot.c" 1
 1603 045c ABBF      		out 59, r26
 1604 045e FC01      		movw r30, r24
 1605 0460 0791      		elpm r16, Z+
 1606               		
 1607               	 ;  0 "" 2
 1608               	.LVL176:
 1609               	/* #NOAPP */
 1610               	.LBE182:
 1611 0462 0A32      		cpi r16,lo8(42)
 1612 0464 01F4      		brne .L88
 1613               	.L91:
1575:stk500boot.c  **** 	PrintNewLine();
 1614               		.loc 1 1575 0
 1615 0466 0E94 0000 		call PrintNewLine
 1616               	.LVL177:
1576:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1617               		.loc 1 1576 0
 1618 046a 0E94 0000 		call PrintNewLine
 1619               	.LVL178:
1577:stk500boot.c  **** 	PrintNewLine();
 1620               		.loc 1 1577 0
 1621 046e 60E0      		ldi r22,0
 1622 0470 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1623 0472 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1624 0474 0E94 0000 		call PrintFromPROGMEMln
 1625               	.LVL179:
1578:stk500boot.c  **** 	errorCount	=	0;
 1626               		.loc 1 1578 0
 1627 0478 0E94 0000 		call PrintNewLine
 1628               	.LVL180:
1579:stk500boot.c  **** 	ii			=	0;
 1629               		.loc 1 1579 0
 1630 047c 812C      		mov r8,__zero_reg__
 1631 047e 912C      		mov r9,__zero_reg__
1580:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1632               		.loc 1 1580 0
 1633 0480 A12C      		mov r10,__zero_reg__
 1634 0482 B12C      		mov r11,__zero_reg__
 1635               	.LVL181:
 1636 0484 00C0      		rjmp .L89
 1637               	.LVL182:
 1638               	.L88:
1557:stk500boot.c  **** #else
 1639               		.loc 1 1557 0
 1640 0486 A114      		cp r10,__zero_reg__
 1641 0488 82E0      		ldi r24,2
 1642 048a B806      		cpc r11,r24
 1643 048c 01F0      		breq .L91
1562:stk500boot.c  **** 		if (theChar == 0)
 1644               		.loc 1 1562 0
 1645 048e 602F      		mov r22,r16
 1646 0490 C501      		movw r24,r10
 1647 0492 0E94 0000 		call eeprom_write_byte
 1648               	.LVL183:
1563:stk500boot.c  **** 		{
 1649               		.loc 1 1563 0
 1650 0496 0111      		cpse r16,__zero_reg__
 1651 0498 00C0      		rjmp .L86
1565:stk500boot.c  **** 		}
 1652               		.loc 1 1565 0
 1653 049a 60E0      		ldi r22,0
 1654 049c 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1655 049e 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1656 04a0 0E94 0000 		call PrintFromPROGMEM
 1657               	.LVL184:
 1658 04a4 00C0      		rjmp .L87
 1659               	.L86:
1569:stk500boot.c  **** 		}
 1660               		.loc 1 1569 0
 1661 04a6 802F      		mov r24,r16
 1662 04a8 0E94 0000 		call sendchar
 1663               	.LVL185:
 1664               	.L87:
1571:stk500boot.c  **** 	}
 1665               		.loc 1 1571 0
 1666 04ac 5FEF      		ldi r21,-1
 1667 04ae A51A      		sub r10,r21
 1668 04b0 B50A      		sbc r11,r21
 1669               	.LVL186:
 1670 04b2 00C0      		rjmp .L85
 1671               	.LVL187:
 1672               	.L95:
1582:stk500boot.c  **** #else
 1673               		.loc 1 1582 0
 1674 04b4 A114      		cp r10,__zero_reg__
 1675 04b6 B2E0      		ldi r27,2
 1676 04b8 BB06      		cpc r11,r27
 1677 04ba 01F0      		breq .L97
1587:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1678               		.loc 1 1587 0
 1679 04bc C501      		movw r24,r10
 1680 04be 0E94 0000 		call eeprom_read_byte
 1681               	.LVL188:
 1682 04c2 782E      		mov r7,r24
 1683               	.LVL189:
1588:stk500boot.c  **** 		{
 1684               		.loc 1 1588 0
 1685 04c4 8111      		cpse r24,__zero_reg__
 1686 04c6 00C0      		rjmp .L92
1590:stk500boot.c  **** 		}
 1687               		.loc 1 1590 0
 1688 04c8 60E0      		ldi r22,0
 1689 04ca 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1690 04cc 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1691 04ce 0E94 0000 		call PrintFromPROGMEM
 1692               	.LVL190:
 1693               	.L93:
1596:stk500boot.c  **** 		{
 1694               		.loc 1 1596 0
 1695 04d2 7016      		cp r7,r16
 1696 04d4 01F0      		breq .L94
1598:stk500boot.c  **** 		}
 1697               		.loc 1 1598 0
 1698 04d6 9FEF      		ldi r25,-1
 1699 04d8 891A      		sub r8,r25
 1700 04da 990A      		sbc r9,r25
 1701               	.LVL191:
 1702               	.L94:
1600:stk500boot.c  **** 	}
 1703               		.loc 1 1600 0
 1704 04dc AFEF      		ldi r26,-1
 1705 04de AA1A      		sub r10,r26
 1706 04e0 BA0A      		sbc r11,r26
 1707               	.LVL192:
 1708               	.L89:
 1709 04e2 C501      		movw r24,r10
 1710 04e4 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1711 04e6 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1712               	.LBB183:
1582:stk500boot.c  **** #else
 1713               		.loc 1 1582 0
 1714 04e8 A0E0      		ldi r26,0
 1715 04ea B0E0      		ldi r27,0
 1716               	/* #APP */
 1717               	 ;  1582 "stk500boot.c" 1
 1718 04ec ABBF      		out 59, r26
 1719 04ee FC01      		movw r30, r24
 1720 04f0 0791      		elpm r16, Z+
 1721               		
 1722               	 ;  0 "" 2
 1723               	.LVL193:
 1724               	/* #NOAPP */
 1725               	.LBE183:
 1726 04f2 0A32      		cpi r16,lo8(42)
 1727 04f4 01F4      		brne .L95
 1728               	.L97:
1602:stk500boot.c  **** 	PrintNewLine();
 1729               		.loc 1 1602 0
 1730 04f6 0E94 0000 		call PrintNewLine
 1731               	.LVL194:
1603:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1732               		.loc 1 1603 0
 1733 04fa 0E94 0000 		call PrintNewLine
 1734               	.LVL195:
1604:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1735               		.loc 1 1604 0
 1736 04fe 60E0      		ldi r22,0
 1737 0500 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1738 0502 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1739 0504 0E94 0000 		call PrintFromPROGMEM
 1740               	.LVL196:
1605:stk500boot.c  **** 	PrintNewLine();
 1741               		.loc 1 1605 0
 1742 0508 61E0      		ldi r22,lo8(1)
 1743 050a 70E0      		ldi r23,0
 1744 050c C401      		movw r24,r8
 1745 050e 0E94 0000 		call PrintDecInt
 1746               	.LVL197:
1606:stk500boot.c  **** 	PrintNewLine();
 1747               		.loc 1 1606 0
 1748 0512 0E94 0000 		call PrintNewLine
 1749               	.LVL198:
1607:stk500boot.c  **** 
 1750               		.loc 1 1607 0
 1751 0516 0E94 0000 		call PrintNewLine
 1752               	.LVL199:
 1753               	.L273:
1609:stk500boot.c  **** 
 1754               		.loc 1 1609 0
 1755 051a 1092 0000 		sts gEepromIndex,__zero_reg__
 1756 051e 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1757 0522 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1758 0526 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1759 052a 00C0      		rjmp .L202
 1760               	.LVL200:
 1761               	.L92:
1594:stk500boot.c  **** 		}
 1762               		.loc 1 1594 0
 1763 052c 0E94 0000 		call sendchar
 1764               	.LVL201:
 1765 0530 00C0      		rjmp .L93
 1766               	.LVL202:
 1767               	.L75:
 1768               	.LBE181:
 1769               	.LBE180:
2063:stk500boot.c  **** 				BlinkLED();
 1770               		.loc 1 2063 0
 1771 0532 62E0      		ldi r22,lo8(2)
 1772 0534 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1773 0536 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1774 0538 0E94 0000 		call PrintFromPROGMEMln
 1775               	.LVL203:
 1776               	.LBB184:
 1777               	.LBB185:
1454:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1778               		.loc 1 1454 0
 1779 053c 279A      		sbi 0x4,7
1455:stk500boot.c  **** 
 1780               		.loc 1 1455 0
 1781 053e 2F9A      		sbi 0x5,7
 1782               	.L98:
 1783               	.LBB186:
 1784               	.LBB187:
 477:stk500boot.c  **** }
 1785               		.loc 1 477 0
 1786 0540 8091 C000 		lds r24,192
 1787               	.LBE187:
 1788               	.LBE186:
1457:stk500boot.c  **** 	{
 1789               		.loc 1 1457 0
 1790 0544 87FD      		sbrc r24,7
 1791 0546 00C0      		rjmp .L125
1459:stk500boot.c  **** 		delay_ms(100);
 1792               		.loc 1 1459 0
 1793 0548 2F98      		cbi 0x5,7
1460:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1794               		.loc 1 1460 0
 1795 054a 84E6      		ldi r24,lo8(100)
 1796 054c 90E0      		ldi r25,0
 1797 054e 0E94 0000 		call delay_ms
 1798               	.LVL204:
1461:stk500boot.c  **** 		delay_ms(100);
 1799               		.loc 1 1461 0
 1800 0552 2F9A      		sbi 0x5,7
1462:stk500boot.c  **** 	}
 1801               		.loc 1 1462 0
 1802 0554 84E6      		ldi r24,lo8(100)
 1803 0556 90E0      		ldi r25,0
 1804 0558 0E94 0000 		call delay_ms
 1805               	.LVL205:
 1806 055c 00C0      		rjmp .L98
 1807               	.LVL206:
 1808               	.L283:
 1809               	.LBE185:
 1810               	.LBE184:
 1811               	.LBB189:
 1812               	.LBB168:
1834:stk500boot.c  **** 				break;
 1813               		.loc 1 1834 0
 1814 055e 12B8      		out 0x2,__zero_reg__
 1815               	.LVL207:
 1816               	.L125:
 1817               	.LBE168:
 1818               	.LBE189:
 1819               	.LBB190:
 1820               	.LBB188:
1464:stk500boot.c  **** }
 1821               		.loc 1 1464 0
 1822 0560 0E94 0000 		call recchar
 1823               	.LVL208:
 1824 0564 00C0      		rjmp .L202
 1825               	.LVL209:
 1826               	.L76:
 1827               	.LBE188:
 1828               	.LBE190:
2068:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1829               		.loc 1 2068 0
 1830 0566 62E0      		ldi r22,lo8(2)
 1831 0568 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1832 056a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1833 056c 0E94 0000 		call PrintFromPROGMEMln
 1834               	.LVL210:
2069:stk500boot.c  **** 				gEepromIndex	+=	256;
 1835               		.loc 1 2069 0
 1836 0570 4091 0000 		lds r20,gEepromIndex
 1837 0574 5091 0000 		lds r21,gEepromIndex+1
 1838 0578 6091 0000 		lds r22,gEepromIndex+2
 1839 057c 7091 0000 		lds r23,gEepromIndex+3
 1840 0580 81E0      		ldi r24,lo8(1)
 1841 0582 0E94 0000 		call DumpHex.constprop.0
 1842               	.LVL211:
2070:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1843               		.loc 1 2070 0
 1844 0586 8091 0000 		lds r24,gEepromIndex
 1845 058a 9091 0000 		lds r25,gEepromIndex+1
 1846 058e A091 0000 		lds r26,gEepromIndex+2
 1847 0592 B091 0000 		lds r27,gEepromIndex+3
 1848 0596 9F5F      		subi r25,-1
 1849 0598 AF4F      		sbci r26,-1
 1850 059a BF4F      		sbci r27,-1
 1851 059c 8093 0000 		sts gEepromIndex,r24
 1852 05a0 9093 0000 		sts gEepromIndex+1,r25
 1853 05a4 A093 0000 		sts gEepromIndex+2,r26
 1854 05a8 B093 0000 		sts gEepromIndex+3,r27
2071:stk500boot.c  **** 				{
 1855               		.loc 1 2071 0
 1856 05ac 8115      		cp r24,__zero_reg__
 1857 05ae 9041      		sbci r25,16
 1858 05b0 A105      		cpc r26,__zero_reg__
 1859 05b2 B105      		cpc r27,__zero_reg__
 1860 05b4 00F4      		brsh .+2
 1861 05b6 00C0      		rjmp .L202
 1862 05b8 00C0      		rjmp .L273
 1863               	.L69:
2078:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1864               		.loc 1 2078 0
 1865 05ba 62E0      		ldi r22,lo8(2)
 1866 05bc 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1867 05be 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1868 05c0 0E94 0000 		call PrintFromPROGMEMln
 1869               	.LVL212:
2079:stk500boot.c  **** 				gFlashIndex	+=	256;
 1870               		.loc 1 2079 0
 1871 05c4 4091 0000 		lds r20,gFlashIndex
 1872 05c8 5091 0000 		lds r21,gFlashIndex+1
 1873 05cc 6091 0000 		lds r22,gFlashIndex+2
 1874 05d0 7091 0000 		lds r23,gFlashIndex+3
 1875 05d4 80E0      		ldi r24,0
 1876 05d6 0E94 0000 		call DumpHex.constprop.0
 1877               	.LVL213:
2080:stk500boot.c  **** 				break;
 1878               		.loc 1 2080 0
 1879 05da 8091 0000 		lds r24,gFlashIndex
 1880 05de 9091 0000 		lds r25,gFlashIndex+1
 1881 05e2 A091 0000 		lds r26,gFlashIndex+2
 1882 05e6 B091 0000 		lds r27,gFlashIndex+3
 1883 05ea 9F5F      		subi r25,-1
 1884 05ec AF4F      		sbci r26,-1
 1885 05ee BF4F      		sbci r27,-1
 1886 05f0 8093 0000 		sts gFlashIndex,r24
 1887 05f4 9093 0000 		sts gFlashIndex+1,r25
 1888 05f8 A093 0000 		sts gFlashIndex+2,r26
 1889 05fc B093 0000 		sts gFlashIndex+3,r27
 1890 0600 00C0      		rjmp .L202
 1891               	.L79:
2084:stk500boot.c  **** 				PrintHelp();
 1892               		.loc 1 2084 0
 1893 0602 62E0      		ldi r22,lo8(2)
 1894 0604 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1895 0606 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1896 0608 0E94 0000 		call PrintFromPROGMEMln
 1897               	.LVL214:
 1898               	.LBB191:
 1899               	.LBB192:
1990:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1900               		.loc 1 1990 0
 1901 060c 60E0      		ldi r22,0
 1902 060e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1903 0610 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1904 0612 0E94 0000 		call PrintFromPROGMEMln
 1905               	.LVL215:
1991:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1906               		.loc 1 1991 0
 1907 0616 60E0      		ldi r22,0
 1908 0618 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1909 061a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1910 061c 0E94 0000 		call PrintFromPROGMEMln
 1911               	.LVL216:
1992:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1912               		.loc 1 1992 0
 1913 0620 60E0      		ldi r22,0
 1914 0622 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1915 0624 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1916 0626 0E94 0000 		call PrintFromPROGMEMln
 1917               	.LVL217:
1993:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1918               		.loc 1 1993 0
 1919 062a 60E0      		ldi r22,0
 1920 062c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1921 062e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1922 0630 0E94 0000 		call PrintFromPROGMEMln
 1923               	.LVL218:
1994:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1924               		.loc 1 1994 0
 1925 0634 60E0      		ldi r22,0
 1926 0636 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1927 0638 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1928 063a 0E94 0000 		call PrintFromPROGMEMln
 1929               	.LVL219:
1995:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1930               		.loc 1 1995 0
 1931 063e 60E0      		ldi r22,0
 1932 0640 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1933 0642 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1934 0644 0E94 0000 		call PrintFromPROGMEMln
 1935               	.LVL220:
1996:stk500boot.c  **** 
 1936               		.loc 1 1996 0
 1937 0648 60E0      		ldi r22,0
 1938 064a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1939 064c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1940 064e 0E94 0000 		call PrintFromPROGMEMln
 1941               	.LVL221:
1998:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1942               		.loc 1 1998 0
 1943 0652 60E0      		ldi r22,0
 1944 0654 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1945 0656 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1946 0658 0E94 0000 		call PrintFromPROGMEMln
 1947               	.LVL222:
1999:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1948               		.loc 1 1999 0
 1949 065c 60E0      		ldi r22,0
 1950 065e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1951 0660 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1952 0662 0E94 0000 		call PrintFromPROGMEMln
 1953               	.LVL223:
2000:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1954               		.loc 1 2000 0
 1955 0666 60E0      		ldi r22,0
 1956 0668 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1957 066a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1958 066c 0E94 0000 		call PrintFromPROGMEMln
 1959               	.LVL224:
2001:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1960               		.loc 1 2001 0
 1961 0670 60E0      		ldi r22,0
 1962 0672 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1963 0674 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1964 0676 0E94 0000 		call PrintFromPROGMEMln
 1965               	.LVL225:
2002:stk500boot.c  **** }
 1966               		.loc 1 2002 0
 1967 067a 60E0      		ldi r22,0
 1968 067c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1969 067e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1970 0680 00C0      		rjmp .L272
 1971               	.L77:
 1972               	.LBE192:
 1973               	.LBE191:
2094:stk500boot.c  **** 				keepGoing	=	false;
 1974               		.loc 1 2094 0
 1975 0682 62E0      		ldi r22,lo8(2)
 1976 0684 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1977 0686 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1978 0688 0E94 0000 		call PrintFromPROGMEMln
 1979               	.LVL226:
 1980               	.LBE143:
 1981               	.LBE142:
 695:stk500boot.c  **** 						isLeave			=	1;
 1982               		.loc 1 695 0
 1983 068c A12C      		mov r10,__zero_reg__
 1984 068e B12C      		mov r11,__zero_reg__
 696:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 1985               		.loc 1 696 0
 1986 0690 9924      		clr r9
 1987 0692 9394      		inc r9
 1988 0694 00C0      		rjmp .L101
 1989               	.LVL227:
 1990               	.L81:
 1991               	.LBB201:
 1992               	.LBB200:
2102:stk500boot.c  **** 				break;
2103:stk500boot.c  **** 
2104:stk500boot.c  **** 			case 'V':
2105:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
 1993               		.loc 1 2105 0
 1994 0696 62E0      		ldi r22,lo8(2)
 1995 0698 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1996 069a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1997 069c 0E94 0000 		call PrintFromPROGMEMln
 1998               	.LVL228:
 1999               	.LBB193:
 2000               	.LBB194:
1645:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 2001               		.loc 1 1645 0
 2002 06a0 60E0      		ldi r22,0
 2003 06a2 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 2004 06a4 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 2005 06a6 0E94 0000 		call PrintFromPROGMEMln
 2006               	.LVL229:
1646:stk500boot.c  **** 	//					 V#   ADDR   op code
 2007               		.loc 1 1646 0
 2008 06aa 60E0      		ldi r22,0
 2009 06ac 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 2010 06ae 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 2011 06b0 0E94 0000 		call PrintFromPROGMEMln
 2012               	.LVL230:
1644:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 2013               		.loc 1 1644 0
 2014 06b4 CE5D      		subi r28,lo8(-290)
 2015 06b6 DE4F      		sbci r29,hi8(-290)
 2016 06b8 1982      		std Y+1,__zero_reg__
 2017 06ba 1882      		st Y,__zero_reg__
 2018 06bc C252      		subi r28,lo8(290)
 2019 06be D140      		sbci r29,hi8(290)
1643:stk500boot.c  **** 	vectorIndex		=	0;
 2020               		.loc 1 1643 0
 2021 06c0 412C      		mov r4,__zero_reg__
 2022 06c2 512C      		mov r5,__zero_reg__
 2023 06c4 3201      		movw r6,r4
 2024               	.LVL231:
 2025               	.L105:
1651:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 2026               		.loc 1 1651 0
 2027 06c6 A301      		movw r20,r6
 2028 06c8 9201      		movw r18,r4
 2029 06ca 5695      		lsr r21
 2030 06cc 4795      		ror r20
 2031 06ce 3795      		ror r19
 2032 06d0 2795      		ror r18
 2033 06d2 C25E      		subi r28,lo8(-286)
 2034 06d4 DE4F      		sbci r29,hi8(-286)
 2035 06d6 2883      		st Y,r18
 2036 06d8 3983      		std Y+1,r19
 2037 06da 4A83      		std Y+2,r20
 2038 06dc 5B83      		std Y+3,r21
 2039 06de CE51      		subi r28,lo8(286)
 2040 06e0 D140      		sbci r29,hi8(286)
 2041               	.LVL232:
1653:stk500boot.c  **** 		sendchar(0x20);
 2042               		.loc 1 1653 0
 2043 06e2 CE5D      		subi r28,lo8(-290)
 2044 06e4 DE4F      		sbci r29,hi8(-290)
 2045 06e6 4881      		ld r20,Y
 2046 06e8 5981      		ldd r21,Y+1
 2047 06ea C252      		subi r28,lo8(290)
 2048 06ec D140      		sbci r29,hi8(290)
 2049 06ee 4F5F      		subi r20,-1
 2050 06f0 5F4F      		sbci r21,-1
 2051 06f2 CE5D      		subi r28,lo8(-290)
 2052 06f4 DE4F      		sbci r29,hi8(-290)
 2053 06f6 5983      		std Y+1,r21
 2054 06f8 4883      		st Y,r20
 2055 06fa C252      		subi r28,lo8(290)
 2056 06fc D140      		sbci r29,hi8(290)
 2057               	.LVL233:
 2058 06fe 62E0      		ldi r22,lo8(2)
 2059 0700 70E0      		ldi r23,0
 2060 0702 CA01      		movw r24,r20
 2061 0704 0E94 0000 		call PrintDecInt
 2062               	.LVL234:
1654:stk500boot.c  **** 		sendchar('-');
 2063               		.loc 1 1654 0
 2064 0708 80E2      		ldi r24,lo8(32)
 2065 070a 0E94 0000 		call sendchar
 2066               	.LVL235:
1655:stk500boot.c  **** 		sendchar(0x20);
 2067               		.loc 1 1655 0
 2068 070e 8DE2      		ldi r24,lo8(45)
 2069 0710 0E94 0000 		call sendchar
 2070               	.LVL236:
1656:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2071               		.loc 1 1656 0
 2072 0714 80E2      		ldi r24,lo8(32)
 2073 0716 0E94 0000 		call sendchar
 2074               	.LVL237:
1657:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2075               		.loc 1 1657 0
 2076 071a 80E0      		ldi r24,0
 2077 071c 0E94 0000 		call PrintHexByte
 2078               	.LVL238:
1658:stk500boot.c  **** 		sendchar(0x20);
 2079               		.loc 1 1658 0
 2080 0720 C25E      		subi r28,lo8(-286)
 2081 0722 DE4F      		sbci r29,hi8(-286)
 2082 0724 8881      		ld r24,Y
 2083 0726 CE51      		subi r28,lo8(286)
 2084 0728 D140      		sbci r29,hi8(286)
 2085 072a 0E94 0000 		call PrintHexByte
 2086               	.LVL239:
1659:stk500boot.c  **** 		sendchar('=');
 2087               		.loc 1 1659 0
 2088 072e 80E2      		ldi r24,lo8(32)
 2089 0730 0E94 0000 		call sendchar
 2090               	.LVL240:
1660:stk500boot.c  **** 		sendchar(0x20);
 2091               		.loc 1 1660 0
 2092 0734 8DE3      		ldi r24,lo8(61)
 2093 0736 0E94 0000 		call sendchar
 2094               	.LVL241:
1661:stk500boot.c  **** 
 2095               		.loc 1 1661 0
 2096 073a 80E2      		ldi r24,lo8(32)
 2097 073c 0E94 0000 		call sendchar
 2098               	.LVL242:
 2099               	.LBB195:
1666:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2100               		.loc 1 1666 0
 2101               	/* #APP */
 2102               	 ;  1666 "stk500boot.c" 1
 2103 0740 6BBE      		out 59, r6
 2104 0742 F201      		movw r30, r4
 2105 0744 A790      		elpm r10, Z+
 2106               		
 2107               	 ;  0 "" 2
 2108               	.LVL243:
 2109               	/* #NOAPP */
 2110 0746 D301      		movw r26,r6
 2111 0748 C201      		movw r24,r4
 2112 074a 0196      		adiw r24,1
 2113 074c A11D      		adc r26,__zero_reg__
 2114 074e B11D      		adc r27,__zero_reg__
 2115               	.LVL244:
 2116               	.LBE195:
 2117               	.LBB196:
1667:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2118               		.loc 1 1667 0
 2119               	/* #APP */
 2120               	 ;  1667 "stk500boot.c" 1
 2121 0750 ABBF      		out 59, r26
 2122 0752 FC01      		movw r30, r24
 2123 0754 9790      		elpm r9, Z+
 2124               		
 2125               	 ;  0 "" 2
 2126               	.LVL245:
 2127               	/* #NOAPP */
 2128 0756 D301      		movw r26,r6
 2129 0758 C201      		movw r24,r4
 2130               	.LVL246:
 2131 075a 0296      		adiw r24,2
 2132 075c A11D      		adc r26,__zero_reg__
 2133 075e B11D      		adc r27,__zero_reg__
 2134               	.LVL247:
 2135               	.LBE196:
 2136               	.LBB197:
1668:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2137               		.loc 1 1668 0
 2138               	/* #APP */
 2139               	 ;  1668 "stk500boot.c" 1
 2140 0760 ABBF      		out 59, r26
 2141 0762 FC01      		movw r30, r24
 2142 0764 B790      		elpm r11, Z+
 2143               		
 2144               	 ;  0 "" 2
 2145               	.LVL248:
 2146               	/* #NOAPP */
 2147               	.LBE197:
 2148               	.LBB198:
1669:stk500boot.c  **** 	#else
 2149               		.loc 1 1669 0
 2150 0766 D301      		movw r26,r6
 2151 0768 C201      		movw r24,r4
 2152               	.LVL249:
 2153 076a 0396      		adiw r24,3
 2154 076c A11D      		adc r26,__zero_reg__
 2155 076e B11D      		adc r27,__zero_reg__
 2156               	/* #APP */
 2157               	 ;  1669 "stk500boot.c" 1
 2158 0770 ABBF      		out 59, r26
 2159 0772 FC01      		movw r30, r24
 2160 0774 0791      		elpm r16, Z+
 2161               		
 2162               	 ;  0 "" 2
 2163               	/* #NOAPP */
 2164 0776 54E0      		ldi r21,4
 2165 0778 450E      		add r4,r21
 2166 077a 511C      		adc r5,__zero_reg__
 2167 077c 611C      		adc r6,__zero_reg__
 2168 077e 711C      		adc r7,__zero_reg__
 2169               	.LVL250:
 2170               	.LBE198:
1667:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2171               		.loc 1 1667 0
 2172 0780 492D      		mov r20,r9
 2173 0782 50E0      		ldi r21,0
 2174 0784 60E0      		ldi r22,0
 2175 0786 70E0      		ldi r23,0
1676:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2176               		.loc 1 1676 0
 2177 0788 762F      		mov r23,r22
 2178 078a 652F      		mov r22,r21
 2179 078c 542F      		mov r21,r20
 2180 078e 4427      		clr r20
 2181 0790 4A0D      		add r20,r10
 2182 0792 511D      		adc r21,__zero_reg__
 2183 0794 611D      		adc r22,__zero_reg__
 2184 0796 711D      		adc r23,__zero_reg__
 2185               	.LVL251:
1680:stk500boot.c  **** 		sendchar(0x20);
 2186               		.loc 1 1680 0
 2187 0798 892D      		mov r24,r9
 2188 079a C35D      		subi r28,lo8(-301)
 2189 079c DE4F      		sbci r29,hi8(-301)
 2190 079e 4883      		st Y,r20
 2191 07a0 CD52      		subi r28,lo8(301)
 2192 07a2 D140      		sbci r29,hi8(301)
 2193 07a4 C25D      		subi r28,lo8(-302)
 2194 07a6 DE4F      		sbci r29,hi8(-302)
 2195 07a8 5883      		st Y,r21
 2196 07aa CE52      		subi r28,lo8(302)
 2197 07ac D140      		sbci r29,hi8(302)
 2198 07ae C15D      		subi r28,lo8(-303)
 2199 07b0 DE4F      		sbci r29,hi8(-303)
 2200 07b2 6883      		st Y,r22
 2201 07b4 CF52      		subi r28,lo8(303)
 2202 07b6 D140      		sbci r29,hi8(303)
 2203 07b8 C05D      		subi r28,lo8(-304)
 2204 07ba DE4F      		sbci r29,hi8(-304)
 2205 07bc 7883      		st Y,r23
 2206 07be C053      		subi r28,lo8(304)
 2207 07c0 D140      		sbci r29,hi8(304)
 2208 07c2 0E94 0000 		call PrintHexByte
 2209               	.LVL252:
1681:stk500boot.c  **** 		PrintHexByte(byte1);
 2210               		.loc 1 1681 0
 2211 07c6 80E2      		ldi r24,lo8(32)
 2212 07c8 0E94 0000 		call sendchar
 2213               	.LVL253:
1682:stk500boot.c  **** 		sendchar(0x20);
 2214               		.loc 1 1682 0
 2215 07cc 8A2D      		mov r24,r10
 2216 07ce 0E94 0000 		call PrintHexByte
 2217               	.LVL254:
1683:stk500boot.c  **** 		PrintHexByte(byte4);
 2218               		.loc 1 1683 0
 2219 07d2 80E2      		ldi r24,lo8(32)
 2220 07d4 0E94 0000 		call sendchar
 2221               	.LVL255:
1684:stk500boot.c  **** 		sendchar(0x20);
 2222               		.loc 1 1684 0
 2223 07d8 802F      		mov r24,r16
 2224 07da 0E94 0000 		call PrintHexByte
 2225               	.LVL256:
1685:stk500boot.c  **** 		PrintHexByte(byte3);
 2226               		.loc 1 1685 0
 2227 07de 80E2      		ldi r24,lo8(32)
 2228 07e0 0E94 0000 		call sendchar
 2229               	.LVL257:
1686:stk500boot.c  **** 		sendchar(0x20);
 2230               		.loc 1 1686 0
 2231 07e4 8B2D      		mov r24,r11
 2232 07e6 0E94 0000 		call PrintHexByte
 2233               	.LVL258:
1687:stk500boot.c  **** 	
 2234               		.loc 1 1687 0
 2235 07ea 80E2      		ldi r24,lo8(32)
 2236 07ec 0E94 0000 		call sendchar
 2237               	.LVL259:
1689:stk500boot.c  **** 		{
 2238               		.loc 1 1689 0
 2239 07f0 C35D      		subi r28,lo8(-301)
 2240 07f2 DE4F      		sbci r29,hi8(-301)
 2241 07f4 4881      		ld r20,Y
 2242 07f6 CD52      		subi r28,lo8(301)
 2243 07f8 D140      		sbci r29,hi8(301)
 2244 07fa C25D      		subi r28,lo8(-302)
 2245 07fc DE4F      		sbci r29,hi8(-302)
 2246 07fe 5881      		ld r21,Y
 2247 0800 CE52      		subi r28,lo8(302)
 2248 0802 D140      		sbci r29,hi8(302)
 2249 0804 C15D      		subi r28,lo8(-303)
 2250 0806 DE4F      		sbci r29,hi8(-303)
 2251 0808 6881      		ld r22,Y
 2252 080a CF52      		subi r28,lo8(303)
 2253 080c D140      		sbci r29,hi8(303)
 2254 080e C05D      		subi r28,lo8(-304)
 2255 0810 DE4F      		sbci r29,hi8(-304)
 2256 0812 7881      		ld r23,Y
 2257 0814 C053      		subi r28,lo8(304)
 2258 0816 D140      		sbci r29,hi8(304)
 2259 0818 4F3F      		cpi r20,-1
 2260 081a 8FEF      		ldi r24,-1
 2261 081c 5807      		cpc r21,r24
 2262 081e 6105      		cpc r22,__zero_reg__
 2263 0820 7105      		cpc r23,__zero_reg__
 2264 0822 01F4      		brne .L102
1691:stk500boot.c  **** 		}
 2265               		.loc 1 1691 0
 2266 0824 60E0      		ldi r22,0
 2267 0826 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2268 0828 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2269 082a 0E94 0000 		call PrintFromPROGMEM
 2270               	.LVL260:
 2271 082e 00C0      		rjmp .L103
 2272               	.L102:
1693:stk500boot.c  **** 		{
 2273               		.loc 1 1693 0
 2274 0830 DB01      		movw r26,r22
 2275 0832 CA01      		movw r24,r20
 2276 0834 8827      		clr r24
 2277 0836 907C      		andi r25,192
 2278 0838 AA27      		clr r26
 2279 083a BB27      		clr r27
 2280 083c 8115      		cp r24,__zero_reg__
 2281 083e 904C      		sbci r25,-64
 2282 0840 A105      		cpc r26,__zero_reg__
 2283 0842 B105      		cpc r27,__zero_reg__
 2284 0844 01F4      		brne .L104
1696:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2285               		.loc 1 1696 0
 2286 0846 4A01      		movw r8,r20
 2287 0848 5B01      		movw r10,r22
 2288 084a FFE3      		ldi r31,63
 2289 084c 9F22      		and r9,r31
 2290 084e AA24      		clr r10
 2291 0850 BB24      		clr r11
 2292               	.LVL261:
1697:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2293               		.loc 1 1697 0
 2294 0852 C25E      		subi r28,lo8(-286)
 2295 0854 DE4F      		sbci r29,hi8(-286)
 2296 0856 8881      		ld r24,Y
 2297 0858 9981      		ldd r25,Y+1
 2298 085a AA81      		ldd r26,Y+2
 2299 085c BB81      		ldd r27,Y+3
 2300 085e CE51      		subi r28,lo8(286)
 2301 0860 D140      		sbci r29,hi8(286)
 2302 0862 880D      		add r24,r8
 2303 0864 991D      		adc r25,r9
 2304 0866 AA1D      		adc r26,r10
 2305 0868 BB1D      		adc r27,r11
 2306               	.LVL262:
1698:stk500boot.c  **** 
 2307               		.loc 1 1698 0
 2308 086a 9C01      		movw r18,r24
 2309 086c AD01      		movw r20,r26
 2310 086e 220F      		lsl r18
 2311 0870 331F      		rol r19
 2312 0872 441F      		rol r20
 2313 0874 551F      		rol r21
 2314 0876 C25E      		subi r28,lo8(-286)
 2315 0878 DE4F      		sbci r29,hi8(-286)
 2316 087a 2883      		st Y,r18
 2317 087c 3983      		std Y+1,r19
 2318 087e 4A83      		std Y+2,r20
 2319 0880 5B83      		std Y+3,r21
 2320 0882 CE51      		subi r28,lo8(286)
 2321 0884 D140      		sbci r29,hi8(286)
 2322               	.LVL263:
1700:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2323               		.loc 1 1700 0
 2324 0886 60E0      		ldi r22,0
 2325 0888 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2326 088a 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2327 088c 0E94 0000 		call PrintFromPROGMEM
 2328               	.LVL264:
1701:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2329               		.loc 1 1701 0
 2330 0890 892D      		mov r24,r9
 2331 0892 0E94 0000 		call PrintHexByte
 2332               	.LVL265:
1702:stk500boot.c  **** 			sendchar(0x20);
 2333               		.loc 1 1702 0
 2334 0896 882D      		mov r24,r8
 2335 0898 0E94 0000 		call PrintHexByte
 2336               	.LVL266:
1703:stk500boot.c  **** 			sendchar('>');
 2337               		.loc 1 1703 0
 2338 089c 80E2      		ldi r24,lo8(32)
 2339 089e 0E94 0000 		call sendchar
 2340               	.LVL267:
1704:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2341               		.loc 1 1704 0
 2342 08a2 8EE3      		ldi r24,lo8(62)
 2343 08a4 0E94 0000 		call sendchar
 2344               	.LVL268:
1705:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2345               		.loc 1 1705 0
 2346 08a8 80E0      		ldi r24,0
 2347 08aa 00C0      		rjmp .L274
 2348               	.LVL269:
 2349               	.L104:
1710:stk500boot.c  **** 		{
 2350               		.loc 1 1710 0
 2351 08ac 4E70      		andi r20,14
 2352 08ae 5E7F      		andi r21,254
 2353 08b0 6627      		clr r22
 2354 08b2 7727      		clr r23
 2355 08b4 4C30      		cpi r20,12
 2356 08b6 5449      		sbci r21,-108
 2357 08b8 6105      		cpc r22,__zero_reg__
 2358 08ba 7105      		cpc r23,__zero_reg__
 2359 08bc 01F0      		breq .+2
 2360 08be 00C0      		rjmp .L103
1669:stk500boot.c  **** 	#else
 2361               		.loc 1 1669 0
 2362 08c0 802F      		mov r24,r16
 2363 08c2 90E0      		ldi r25,0
 2364 08c4 A0E0      		ldi r26,0
 2365 08c6 B0E0      		ldi r27,0
1677:stk500boot.c  **** 
 2366               		.loc 1 1677 0
 2367 08c8 BA2F      		mov r27,r26
 2368 08ca A92F      		mov r26,r25
 2369 08cc 982F      		mov r25,r24
 2370 08ce 8827      		clr r24
 2371 08d0 8B0D      		add r24,r11
 2372 08d2 911D      		adc r25,__zero_reg__
 2373 08d4 A11D      		adc r26,__zero_reg__
 2374 08d6 B11D      		adc r27,__zero_reg__
1713:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2375               		.loc 1 1713 0
 2376 08d8 4A2D      		mov r20,r10
 2377 08da 4170      		andi r20,lo8(1)
 2378 08dc 50E0      		ldi r21,0
 2379 08de 60E0      		ldi r22,0
 2380 08e0 70E0      		ldi r23,0
 2381 08e2 BA01      		movw r22,r20
 2382 08e4 5527      		clr r21
 2383 08e6 4427      		clr r20
 2384 08e8 480F      		add r20,r24
 2385 08ea 591F      		adc r21,r25
 2386 08ec 6A1F      		adc r22,r26
 2387 08ee 7B1F      		adc r23,r27
1714:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2388               		.loc 1 1714 0
 2389 08f0 8A2D      		mov r24,r10
 2390 08f2 807F      		andi r24,lo8(-16)
 2391 08f4 90E0      		ldi r25,0
 2392 08f6 A0E0      		ldi r26,0
 2393 08f8 B0E0      		ldi r27,0
 2394 08fa F1E1      		ldi r31,17
 2395               		1:
 2396 08fc 880F      		lsl r24
 2397 08fe 991F      		rol r25
 2398 0900 AA1F      		rol r26
 2399 0902 BB1F      		rol r27
 2400 0904 FA95      		dec r31
 2401 0906 01F4      		brne 1b
 2402 0908 840F      		add r24,r20
 2403 090a 951F      		adc r25,r21
 2404 090c A61F      		adc r26,r22
 2405 090e B71F      		adc r27,r23
1715:stk500boot.c  **** 								word2;
 2406               		.loc 1 1715 0
 2407 0910 292D      		mov r18,r9
 2408 0912 2170      		andi r18,lo8(1)
 2409 0914 822E      		mov r8,r18
 2410 0916 912C      		mov r9,__zero_reg__
 2411               	.LVL270:
 2412 0918 A12C      		mov r10,__zero_reg__
 2413 091a B12C      		mov r11,__zero_reg__
 2414               	.LVL271:
 2415 091c 05E1      		ldi r16,21
 2416               		1:
 2417 091e 880C      		lsl r8
 2418 0920 991C      		rol r9
 2419 0922 AA1C      		rol r10
 2420 0924 BB1C      		rol r11
 2421 0926 0A95      		dec r16
 2422 0928 01F4      		brne 1b
 2423               	.LVL272:
1713:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2424               		.loc 1 1713 0
 2425 092a 880E      		add r8,r24
 2426 092c 991E      		adc r9,r25
 2427 092e AA1E      		adc r10,r26
 2428 0930 BB1E      		adc r11,r27
 2429               	.LVL273:
1718:stk500boot.c  **** 							
 2430               		.loc 1 1718 0
 2431 0932 A501      		movw r20,r10
 2432 0934 9401      		movw r18,r8
 2433 0936 220F      		lsl r18
 2434 0938 331F      		rol r19
 2435 093a 441F      		rol r20
 2436 093c 551F      		rol r21
 2437 093e C25E      		subi r28,lo8(-286)
 2438 0940 DE4F      		sbci r29,hi8(-286)
 2439 0942 2883      		st Y,r18
 2440 0944 3983      		std Y+1,r19
 2441 0946 4A83      		std Y+2,r20
 2442 0948 5B83      		std Y+3,r21
 2443 094a CE51      		subi r28,lo8(286)
 2444 094c D140      		sbci r29,hi8(286)
 2445               	.LVL274:
1720:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2446               		.loc 1 1720 0
 2447 094e 60E0      		ldi r22,0
 2448 0950 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2449 0952 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2450 0954 0E94 0000 		call PrintFromPROGMEM
 2451               	.LVL275:
1721:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2452               		.loc 1 1721 0
 2453 0958 8A2D      		mov r24,r10
 2454 095a 0E94 0000 		call PrintHexByte
 2455               	.LVL276:
1722:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2456               		.loc 1 1722 0
 2457 095e 892D      		mov r24,r9
 2458 0960 0E94 0000 		call PrintHexByte
 2459               	.LVL277:
1723:stk500boot.c  **** 			sendchar(0x20);
 2460               		.loc 1 1723 0
 2461 0964 882D      		mov r24,r8
 2462 0966 0E94 0000 		call PrintHexByte
 2463               	.LVL278:
1724:stk500boot.c  **** 			sendchar('>');
 2464               		.loc 1 1724 0
 2465 096a 80E2      		ldi r24,lo8(32)
 2466 096c 0E94 0000 		call sendchar
 2467               	.LVL279:
1725:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2468               		.loc 1 1725 0
 2469 0970 8EE3      		ldi r24,lo8(62)
 2470 0972 0E94 0000 		call sendchar
 2471               	.LVL280:
1726:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2472               		.loc 1 1726 0
 2473 0976 C05E      		subi r28,lo8(-288)
 2474 0978 DE4F      		sbci r29,hi8(-288)
 2475 097a 8881      		ld r24,Y
 2476 097c C052      		subi r28,lo8(288)
 2477 097e D140      		sbci r29,hi8(288)
 2478               	.LVL281:
 2479               	.L274:
 2480 0980 0E94 0000 		call PrintHexByte
 2481               	.LVL282:
1727:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2482               		.loc 1 1727 0
 2483 0984 C15E      		subi r28,lo8(-287)
 2484 0986 DE4F      		sbci r29,hi8(-287)
 2485 0988 8881      		ld r24,Y
 2486 098a CF51      		subi r28,lo8(287)
 2487 098c D140      		sbci r29,hi8(287)
 2488 098e 0E94 0000 		call PrintHexByte
 2489               	.LVL283:
1728:stk500boot.c  **** 		}
 2490               		.loc 1 1728 0
 2491 0992 C25E      		subi r28,lo8(-286)
 2492 0994 DE4F      		sbci r29,hi8(-286)
 2493 0996 8881      		ld r24,Y
 2494 0998 CE51      		subi r28,lo8(286)
 2495 099a D140      		sbci r29,hi8(286)
 2496 099c 0E94 0000 		call PrintHexByte
 2497               	.LVL284:
 2498               	.L103:
1740:stk500boot.c  **** 
 2499               		.loc 1 1740 0
 2500 09a0 0E94 0000 		call PrintNewLine
 2501               	.LVL285:
1649:stk500boot.c  **** 	{
 2502               		.loc 1 1649 0
 2503 09a4 CE5D      		subi r28,lo8(-290)
 2504 09a6 DE4F      		sbci r29,hi8(-290)
 2505 09a8 4881      		ld r20,Y
 2506 09aa 5981      		ldd r21,Y+1
 2507 09ac C252      		subi r28,lo8(290)
 2508 09ae D140      		sbci r29,hi8(290)
 2509 09b0 4933      		cpi r20,57
 2510 09b2 5105      		cpc r21,__zero_reg__
 2511 09b4 01F0      		breq .+2
 2512 09b6 00C0      		rjmp .L105
 2513 09b8 00C0      		rjmp .L202
 2514               	.LVL286:
 2515               	.L82:
 2516               	.LBE194:
 2517               	.LBE193:
2106:stk500boot.c  **** 				VectorDisplay();
2107:stk500boot.c  **** 				break;
2108:stk500boot.c  **** 
2109:stk500boot.c  **** 			case 'Y':
2110:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
 2518               		.loc 1 2110 0
 2519 09ba 62E0      		ldi r22,lo8(2)
 2520 09bc 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2521 09be 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2522 09c0 0E94 0000 		call PrintFromPROGMEMln
 2523               	.LVL287:
 2524               	.LBB199:
 2525               	.LBB169:
1814:stk500boot.c  **** 
 2526               		.loc 1 1814 0
 2527 09c4 60E0      		ldi r22,0
 2528 09c6 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2529 09c8 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2530 09ca 0E94 0000 		call PrintFromPROGMEM
 2531               	.LVL288:
1816:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2532               		.loc 1 1816 0
 2533 09ce 0E94 0000 		call recchar
 2534               	.LVL289:
1817:stk500boot.c  **** 	sendchar(portLetter);
 2535               		.loc 1 1817 0
 2536 09d2 082F      		mov r16,r24
 2537               	.LVL290:
 2538 09d4 0F75      		andi r16,lo8(95)
 2539               	.LVL291:
1818:stk500boot.c  **** 	PrintNewLine();
 2540               		.loc 1 1818 0
 2541 09d6 802F      		mov r24,r16
 2542 09d8 0E94 0000 		call sendchar
 2543               	.LVL292:
1819:stk500boot.c  **** 
 2544               		.loc 1 1819 0
 2545 09dc 0E94 0000 		call PrintNewLine
 2546               	.LVL293:
1821:stk500boot.c  **** 	{
 2547               		.loc 1 1821 0
 2548 09e0 8FEB      		ldi r24,lo8(-65)
 2549 09e2 800F      		add r24,r16
 2550 09e4 8A31      		cpi r24,lo8(26)
 2551 09e6 00F0      		brlo .+2
 2552 09e8 00C0      		rjmp .L107
 2553               	.LVL294:
1824:stk500boot.c  **** 		{
 2554               		.loc 1 1824 0
 2555 09ea 0634      		cpi r16,lo8(70)
 2556 09ec 01F4      		brne .+2
 2557 09ee 00C0      		rjmp .L109
 2558 09f0 00F4      		brsh .L110
 2559 09f2 0334      		cpi r16,lo8(67)
 2560 09f4 01F4      		brne .+2
 2561 09f6 00C0      		rjmp .L111
 2562 09f8 00F4      		brsh .L112
 2563 09fa 0134      		cpi r16,lo8(65)
 2564 09fc 01F0      		breq .L113
 2565 09fe 0234      		cpi r16,lo8(66)
 2566 0a00 01F0      		breq .+2
 2567 0a02 00C0      		rjmp .L108
1840:stk500boot.c  **** 				while (!Serial_Available())
 2568               		.loc 1 1840 0
 2569 0a04 14B9      		out 0x4,r17
 2570 0a06 00C0      		rjmp .L126
 2571               	.L112:
1824:stk500boot.c  **** 		{
 2572               		.loc 1 1824 0
 2573 0a08 0434      		cpi r16,lo8(68)
 2574 0a0a 01F4      		brne .+2
 2575 0a0c 00C0      		rjmp .L115
 2576 0a0e 0534      		cpi r16,lo8(69)
 2577 0a10 01F0      		breq .+2
 2578 0a12 00C0      		rjmp .L108
1876:stk500boot.c  **** 				while (!Serial_Available())
 2579               		.loc 1 1876 0
 2580 0a14 1DB9      		out 0xd,r17
 2581 0a16 00C0      		rjmp .L132
 2582               	.L110:
1824:stk500boot.c  **** 		{
 2583               		.loc 1 1824 0
 2584 0a18 0A34      		cpi r16,lo8(74)
 2585 0a1a 01F4      		brne .+2
 2586 0a1c 00C0      		rjmp .L117
 2587 0a1e 00F4      		brsh .L118
 2588 0a20 0734      		cpi r16,lo8(71)
 2589 0a22 01F4      		brne .+2
 2590 0a24 00C0      		rjmp .L119
 2591 0a26 0834      		cpi r16,lo8(72)
 2592 0a28 01F0      		breq .+2
 2593 0a2a 00C0      		rjmp .L108
1912:stk500boot.c  **** 				while (!Serial_Available())
 2594               		.loc 1 1912 0
 2595 0a2c 1093 0101 		sts 257,r17
 2596 0a30 00C0      		rjmp .L138
 2597               	.L118:
1824:stk500boot.c  **** 		{
 2598               		.loc 1 1824 0
 2599 0a32 0B34      		cpi r16,lo8(75)
 2600 0a34 01F4      		brne .+2
 2601 0a36 00C0      		rjmp .L121
 2602 0a38 0C34      		cpi r16,lo8(76)
 2603 0a3a 01F0      		breq .+2
 2604 0a3c 00C0      		rjmp .L108
1960:stk500boot.c  **** 				while (!Serial_Available())
 2605               		.loc 1 1960 0
 2606 0a3e 1093 0A01 		sts 266,r17
 2607 0a42 00C0      		rjmp .L144
 2608               	.L113:
1828:stk500boot.c  **** 				while (!Serial_Available())
 2609               		.loc 1 1828 0
 2610 0a44 11B9      		out 0x1,r17
 2611               	.L123:
 2612               	.LBB146:
 2613               	.LBB147:
 477:stk500boot.c  **** }
 2614               		.loc 1 477 0
 2615 0a46 8091 C000 		lds r24,192
 2616               	.LBE147:
 2617               	.LBE146:
1829:stk500boot.c  **** 				{
 2618               		.loc 1 1829 0
 2619 0a4a 87FD      		sbrc r24,7
 2620 0a4c 00C0      		rjmp .L283
1831:stk500boot.c  **** 					delay_ms(200);
 2621               		.loc 1 1831 0
 2622 0a4e 82B1      		in r24,0x2
 2623 0a50 8095      		com r24
 2624 0a52 82B9      		out 0x2,r24
1832:stk500boot.c  **** 				}
 2625               		.loc 1 1832 0
 2626 0a54 88EC      		ldi r24,lo8(-56)
 2627 0a56 90E0      		ldi r25,0
 2628 0a58 0E94 0000 		call delay_ms
 2629               	.LVL295:
 2630 0a5c 00C0      		rjmp .L123
 2631               	.L126:
 2632               	.LBB148:
 2633               	.LBB149:
 477:stk500boot.c  **** }
 2634               		.loc 1 477 0
 2635 0a5e 8091 C000 		lds r24,192
 2636               	.LBE149:
 2637               	.LBE148:
1841:stk500boot.c  **** 				{
 2638               		.loc 1 1841 0
 2639 0a62 87FD      		sbrc r24,7
 2640 0a64 00C0      		rjmp .L284
1843:stk500boot.c  **** 					delay_ms(200);
 2641               		.loc 1 1843 0
 2642 0a66 85B1      		in r24,0x5
 2643 0a68 8095      		com r24
 2644 0a6a 85B9      		out 0x5,r24
1844:stk500boot.c  **** 				}
 2645               		.loc 1 1844 0
 2646 0a6c 88EC      		ldi r24,lo8(-56)
 2647 0a6e 90E0      		ldi r25,0
 2648 0a70 0E94 0000 		call delay_ms
 2649               	.LVL296:
 2650 0a74 00C0      		rjmp .L126
 2651               	.L284:
1846:stk500boot.c  **** 				break;
 2652               		.loc 1 1846 0
 2653 0a76 15B8      		out 0x5,__zero_reg__
 2654 0a78 00C0      		rjmp .L125
 2655               	.L111:
1852:stk500boot.c  **** 				while (!Serial_Available())
 2656               		.loc 1 1852 0
 2657 0a7a 17B9      		out 0x7,r17
 2658               	.L128:
 2659               	.LBB150:
 2660               	.LBB151:
 477:stk500boot.c  **** }
 2661               		.loc 1 477 0
 2662 0a7c 8091 C000 		lds r24,192
 2663               	.LBE151:
 2664               	.LBE150:
1853:stk500boot.c  **** 				{
 2665               		.loc 1 1853 0
 2666 0a80 87FD      		sbrc r24,7
 2667 0a82 00C0      		rjmp .L285
1855:stk500boot.c  **** 					delay_ms(200);
 2668               		.loc 1 1855 0
 2669 0a84 88B1      		in r24,0x8
 2670 0a86 8095      		com r24
 2671 0a88 88B9      		out 0x8,r24
1856:stk500boot.c  **** 				}
 2672               		.loc 1 1856 0
 2673 0a8a 88EC      		ldi r24,lo8(-56)
 2674 0a8c 90E0      		ldi r25,0
 2675 0a8e 0E94 0000 		call delay_ms
 2676               	.LVL297:
 2677 0a92 00C0      		rjmp .L128
 2678               	.L285:
1858:stk500boot.c  **** 				break;
 2679               		.loc 1 1858 0
 2680 0a94 18B8      		out 0x8,__zero_reg__
 2681 0a96 00C0      		rjmp .L125
 2682               	.L115:
1864:stk500boot.c  **** 				while (!Serial_Available())
 2683               		.loc 1 1864 0
 2684 0a98 1AB9      		out 0xa,r17
 2685               	.L130:
 2686               	.LBB152:
 2687               	.LBB153:
 477:stk500boot.c  **** }
 2688               		.loc 1 477 0
 2689 0a9a 8091 C000 		lds r24,192
 2690               	.LBE153:
 2691               	.LBE152:
1865:stk500boot.c  **** 				{
 2692               		.loc 1 1865 0
 2693 0a9e 87FD      		sbrc r24,7
 2694 0aa0 00C0      		rjmp .L286
1867:stk500boot.c  **** 					delay_ms(200);
 2695               		.loc 1 1867 0
 2696 0aa2 8BB1      		in r24,0xb
 2697 0aa4 8095      		com r24
 2698 0aa6 8BB9      		out 0xb,r24
1868:stk500boot.c  **** 				}
 2699               		.loc 1 1868 0
 2700 0aa8 88EC      		ldi r24,lo8(-56)
 2701 0aaa 90E0      		ldi r25,0
 2702 0aac 0E94 0000 		call delay_ms
 2703               	.LVL298:
 2704 0ab0 00C0      		rjmp .L130
 2705               	.L286:
1870:stk500boot.c  **** 				break;
 2706               		.loc 1 1870 0
 2707 0ab2 1BB8      		out 0xb,__zero_reg__
 2708 0ab4 00C0      		rjmp .L125
 2709               	.L132:
 2710               	.LBB154:
 2711               	.LBB155:
 477:stk500boot.c  **** }
 2712               		.loc 1 477 0
 2713 0ab6 8091 C000 		lds r24,192
 2714               	.LBE155:
 2715               	.LBE154:
1877:stk500boot.c  **** 				{
 2716               		.loc 1 1877 0
 2717 0aba 87FD      		sbrc r24,7
 2718 0abc 00C0      		rjmp .L287
1879:stk500boot.c  **** 					delay_ms(200);
 2719               		.loc 1 1879 0
 2720 0abe 8EB1      		in r24,0xe
 2721 0ac0 8095      		com r24
 2722 0ac2 8EB9      		out 0xe,r24
1880:stk500boot.c  **** 				}
 2723               		.loc 1 1880 0
 2724 0ac4 88EC      		ldi r24,lo8(-56)
 2725 0ac6 90E0      		ldi r25,0
 2726 0ac8 0E94 0000 		call delay_ms
 2727               	.LVL299:
 2728 0acc 00C0      		rjmp .L132
 2729               	.L287:
1882:stk500boot.c  **** 				break;
 2730               		.loc 1 1882 0
 2731 0ace 1EB8      		out 0xe,__zero_reg__
 2732 0ad0 00C0      		rjmp .L125
 2733               	.L109:
1888:stk500boot.c  **** 				while (!Serial_Available())
 2734               		.loc 1 1888 0
 2735 0ad2 10BB      		out 0x10,r17
 2736               	.L134:
 2737               	.LBB156:
 2738               	.LBB157:
 477:stk500boot.c  **** }
 2739               		.loc 1 477 0
 2740 0ad4 8091 C000 		lds r24,192
 2741               	.LBE157:
 2742               	.LBE156:
1889:stk500boot.c  **** 				{
 2743               		.loc 1 1889 0
 2744 0ad8 87FD      		sbrc r24,7
 2745 0ada 00C0      		rjmp .L288
1891:stk500boot.c  **** 					delay_ms(200);
 2746               		.loc 1 1891 0
 2747 0adc 81B3      		in r24,0x11
 2748 0ade 8095      		com r24
 2749 0ae0 81BB      		out 0x11,r24
1892:stk500boot.c  **** 				}
 2750               		.loc 1 1892 0
 2751 0ae2 88EC      		ldi r24,lo8(-56)
 2752 0ae4 90E0      		ldi r25,0
 2753 0ae6 0E94 0000 		call delay_ms
 2754               	.LVL300:
 2755 0aea 00C0      		rjmp .L134
 2756               	.L288:
1894:stk500boot.c  **** 				break;
 2757               		.loc 1 1894 0
 2758 0aec 11BA      		out 0x11,__zero_reg__
 2759 0aee 00C0      		rjmp .L125
 2760               	.L119:
1900:stk500boot.c  **** 				while (!Serial_Available())
 2761               		.loc 1 1900 0
 2762 0af0 13BB      		out 0x13,r17
 2763               	.L136:
 2764               	.LBB158:
 2765               	.LBB159:
 477:stk500boot.c  **** }
 2766               		.loc 1 477 0
 2767 0af2 8091 C000 		lds r24,192
 2768               	.LBE159:
 2769               	.LBE158:
1901:stk500boot.c  **** 				{
 2770               		.loc 1 1901 0
 2771 0af6 87FD      		sbrc r24,7
 2772 0af8 00C0      		rjmp .L289
1903:stk500boot.c  **** 					delay_ms(200);
 2773               		.loc 1 1903 0
 2774 0afa 84B3      		in r24,0x14
 2775 0afc 8095      		com r24
 2776 0afe 84BB      		out 0x14,r24
1904:stk500boot.c  **** 				}
 2777               		.loc 1 1904 0
 2778 0b00 88EC      		ldi r24,lo8(-56)
 2779 0b02 90E0      		ldi r25,0
 2780 0b04 0E94 0000 		call delay_ms
 2781               	.LVL301:
 2782 0b08 00C0      		rjmp .L136
 2783               	.L289:
1906:stk500boot.c  **** 				break;
 2784               		.loc 1 1906 0
 2785 0b0a 14BA      		out 0x14,__zero_reg__
 2786 0b0c 00C0      		rjmp .L125
 2787               	.L138:
 2788               	.LBB160:
 2789               	.LBB161:
 477:stk500boot.c  **** }
 2790               		.loc 1 477 0
 2791 0b0e 8091 C000 		lds r24,192
 2792               	.LBE161:
 2793               	.LBE160:
1913:stk500boot.c  **** 				{
 2794               		.loc 1 1913 0
 2795 0b12 87FD      		sbrc r24,7
 2796 0b14 00C0      		rjmp .L290
1915:stk500boot.c  **** 					delay_ms(200);
 2797               		.loc 1 1915 0
 2798 0b16 8091 0201 		lds r24,258
 2799 0b1a 8095      		com r24
 2800 0b1c 8093 0201 		sts 258,r24
1916:stk500boot.c  **** 				}
 2801               		.loc 1 1916 0
 2802 0b20 88EC      		ldi r24,lo8(-56)
 2803 0b22 90E0      		ldi r25,0
 2804 0b24 0E94 0000 		call delay_ms
 2805               	.LVL302:
 2806 0b28 00C0      		rjmp .L138
 2807               	.L290:
1918:stk500boot.c  **** 				break;
 2808               		.loc 1 1918 0
 2809 0b2a 1092 0201 		sts 258,__zero_reg__
 2810 0b2e 00C0      		rjmp .L125
 2811               	.L117:
1936:stk500boot.c  **** 				while (!Serial_Available())
 2812               		.loc 1 1936 0
 2813 0b30 1093 0401 		sts 260,r17
 2814               	.L140:
 2815               	.LBB162:
 2816               	.LBB163:
 477:stk500boot.c  **** }
 2817               		.loc 1 477 0
 2818 0b34 8091 C000 		lds r24,192
 2819               	.LBE163:
 2820               	.LBE162:
1937:stk500boot.c  **** 				{
 2821               		.loc 1 1937 0
 2822 0b38 87FD      		sbrc r24,7
 2823 0b3a 00C0      		rjmp .L291
1939:stk500boot.c  **** 					delay_ms(200);
 2824               		.loc 1 1939 0
 2825 0b3c 8091 0501 		lds r24,261
 2826 0b40 8095      		com r24
 2827 0b42 8093 0501 		sts 261,r24
1940:stk500boot.c  **** 				}
 2828               		.loc 1 1940 0
 2829 0b46 88EC      		ldi r24,lo8(-56)
 2830 0b48 90E0      		ldi r25,0
 2831 0b4a 0E94 0000 		call delay_ms
 2832               	.LVL303:
 2833 0b4e 00C0      		rjmp .L140
 2834               	.L291:
1942:stk500boot.c  **** 				break;
 2835               		.loc 1 1942 0
 2836 0b50 1092 0501 		sts 261,__zero_reg__
 2837 0b54 00C0      		rjmp .L125
 2838               	.L121:
1948:stk500boot.c  **** 				while (!Serial_Available())
 2839               		.loc 1 1948 0
 2840 0b56 1093 0701 		sts 263,r17
 2841               	.L142:
 2842               	.LBB164:
 2843               	.LBB165:
 477:stk500boot.c  **** }
 2844               		.loc 1 477 0
 2845 0b5a 8091 C000 		lds r24,192
 2846               	.LBE165:
 2847               	.LBE164:
1949:stk500boot.c  **** 				{
 2848               		.loc 1 1949 0
 2849 0b5e 87FD      		sbrc r24,7
 2850 0b60 00C0      		rjmp .L292
1951:stk500boot.c  **** 					delay_ms(200);
 2851               		.loc 1 1951 0
 2852 0b62 8091 0801 		lds r24,264
 2853 0b66 8095      		com r24
 2854 0b68 8093 0801 		sts 264,r24
1952:stk500boot.c  **** 				}
 2855               		.loc 1 1952 0
 2856 0b6c 88EC      		ldi r24,lo8(-56)
 2857 0b6e 90E0      		ldi r25,0
 2858 0b70 0E94 0000 		call delay_ms
 2859               	.LVL304:
 2860 0b74 00C0      		rjmp .L142
 2861               	.L292:
1954:stk500boot.c  **** 				break;
 2862               		.loc 1 1954 0
 2863 0b76 1092 0801 		sts 264,__zero_reg__
 2864 0b7a 00C0      		rjmp .L125
 2865               	.L144:
 2866               	.LBB166:
 2867               	.LBB167:
 477:stk500boot.c  **** }
 2868               		.loc 1 477 0
 2869 0b7c 8091 C000 		lds r24,192
 2870               	.LBE167:
 2871               	.LBE166:
1961:stk500boot.c  **** 				{
 2872               		.loc 1 1961 0
 2873 0b80 87FD      		sbrc r24,7
 2874 0b82 00C0      		rjmp .L293
1963:stk500boot.c  **** 					delay_ms(200);
 2875               		.loc 1 1963 0
 2876 0b84 8091 0B01 		lds r24,267
 2877 0b88 8095      		com r24
 2878 0b8a 8093 0B01 		sts 267,r24
1964:stk500boot.c  **** 				}
 2879               		.loc 1 1964 0
 2880 0b8e 88EC      		ldi r24,lo8(-56)
 2881 0b90 90E0      		ldi r25,0
 2882 0b92 0E94 0000 		call delay_ms
 2883               	.LVL305:
 2884 0b96 00C0      		rjmp .L144
 2885               	.L293:
1966:stk500boot.c  **** 				break;
 2886               		.loc 1 1966 0
 2887 0b98 1092 0B01 		sts 267,__zero_reg__
 2888 0b9c 00C0      		rjmp .L125
 2889               	.L108:
1971:stk500boot.c  **** 				getCharFlag	=	false;
 2890               		.loc 1 1971 0
 2891 0b9e 60E0      		ldi r22,0
 2892 0ba0 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2893 0ba2 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2894 0ba4 00C0      		rjmp .L272
 2895               	.LVL306:
 2896               	.L107:
1982:stk500boot.c  **** 	}
 2897               		.loc 1 1982 0
 2898 0ba6 60E0      		ldi r22,0
 2899 0ba8 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2900 0baa 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2901 0bac 00C0      		rjmp .L272
 2902               	.LVL307:
 2903               	.L68:
 2904               	.LBE169:
 2905               	.LBE199:
2111:stk500boot.c  **** 				AVR_PortOutput();
2112:stk500boot.c  **** 				break;
2113:stk500boot.c  **** 			
2114:stk500boot.c  **** 			default:
2115:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 2906               		.loc 1 2115 0
 2907 0bae 60E0      		ldi r22,0
 2908 0bb0 80E0      		ldi r24,lo8(gTextMsg_HUH)
 2909 0bb2 90E0      		ldi r25,hi8(gTextMsg_HUH)
 2910               	.LVL308:
 2911               	.L272:
 2912 0bb4 0E94 0000 		call PrintFromPROGMEMln
 2913               	.LVL309:
 2914 0bb8 00C0      		rjmp .L202
 2915               	.LVL310:
 2916               	.L60:
 2917               	.LBE200:
 2918               	.LBE201:
 707:stk500boot.c  **** 				{
 2919               		.loc 1 707 0
 2920 0bba 8330      		cpi r24,lo8(3)
 2921 0bbc 01F0      		breq .L210
 2922 0bbe 00F4      		brsh .L148
 2923 0bc0 8130      		cpi r24,lo8(1)
 2924 0bc2 01F0      		breq .L208
 2925 0bc4 00F0      		brlo .L268
 2926 0bc6 00C0      		rjmp .L294
 2927               	.L148:
 2928 0bc8 8530      		cpi r24,lo8(5)
 2929 0bca 01F0      		breq .L211
 2930 0bcc 00F0      		brlo .L153
 2931 0bce 8630      		cpi r24,lo8(6)
 2932 0bd0 01F0      		breq .+2
 2933 0bd2 00C0      		rjmp .L295
 703:stk500boot.c  **** 				}
 2934               		.loc 1 703 0
 2935 0bd4 A12C      		mov r10,__zero_reg__
 2936 0bd6 B12C      		mov r11,__zero_reg__
 2937 0bd8 00C0      		rjmp .L154
 2938               	.L268:
 2939 0bda A12C      		mov r10,__zero_reg__
 2940 0bdc B12C      		mov r11,__zero_reg__
 710:stk500boot.c  **** 						{
 2941               		.loc 1 710 0
 2942 0bde 9B31      		cpi r25,lo8(27)
 2943 0be0 01F4      		brne .+2
 2944 0be2 00C0      		rjmp .L155
 2945               	.LVL311:
 2946               	.L157:
 2947 0be4 40E0      		ldi r20,0
 2948 0be6 50E0      		ldi r21,0
 2949 0be8 00C0      		rjmp .L200
 2950               	.LVL312:
 2951               	.L208:
 703:stk500boot.c  **** 				}
 2952               		.loc 1 703 0
 2953 0bea A12C      		mov r10,__zero_reg__
 2954 0bec B12C      		mov r11,__zero_reg__
 2955               	.LVL313:
 2956               	.L149:
 721:stk500boot.c  **** 					#else
 2957               		.loc 1 721 0
 2958 0bee 1927      		eor r17,r25
 2959               	.LVL314:
 734:stk500boot.c  **** 
 2960               		.loc 1 734 0
 2961 0bf0 C65D      		subi r28,lo8(-298)
 2962 0bf2 DE4F      		sbci r29,hi8(-298)
 2963 0bf4 9883      		st Y,r25
 2964 0bf6 CA52      		subi r28,lo8(298)
 2965 0bf8 D140      		sbci r29,hi8(298)
 720:stk500boot.c  **** 						checksum		^=	c;
 2966               		.loc 1 720 0
 2967 0bfa 82E0      		ldi r24,lo8(2)
 734:stk500boot.c  **** 
 2968               		.loc 1 734 0
 2969 0bfc 00C0      		rjmp .L157
 2970               	.LVL315:
 2971               	.L294:
 703:stk500boot.c  **** 				}
 2972               		.loc 1 703 0
 2973 0bfe A12C      		mov r10,__zero_reg__
 2974 0c00 B12C      		mov r11,__zero_reg__
 2975               	.LVL316:
 2976               	.L150:
 737:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2977               		.loc 1 737 0
 2978 0c02 292F      		mov r18,r25
 2979               	.LVL317:
 2980 0c04 30E0      		ldi r19,0
 2981 0c06 322F      		mov r19,r18
 2982 0c08 2227      		clr r18
 2983               	.LVL318:
 739:stk500boot.c  **** 						break;
 2984               		.loc 1 739 0
 2985 0c0a 1927      		eor r17,r25
 2986               	.LVL319:
 738:stk500boot.c  **** 						checksum		^=	c;
 2987               		.loc 1 738 0
 2988 0c0c 83E0      		ldi r24,lo8(3)
 740:stk500boot.c  **** 
 2989               		.loc 1 740 0
 2990 0c0e 00C0      		rjmp .L157
 2991               	.LVL320:
 2992               	.L210:
 703:stk500boot.c  **** 				}
 2993               		.loc 1 703 0
 2994 0c10 A12C      		mov r10,__zero_reg__
 2995 0c12 B12C      		mov r11,__zero_reg__
 2996               	.LVL321:
 2997               	.L147:
 743:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 2998               		.loc 1 743 0
 2999 0c14 292B      		or r18,r25
 3000               	.LVL322:
 745:stk500boot.c  **** 						break;
 3001               		.loc 1 745 0
 3002 0c16 1927      		eor r17,r25
 3003               	.LVL323:
 744:stk500boot.c  **** 						checksum		^=	c;
 3004               		.loc 1 744 0
 3005 0c18 84E0      		ldi r24,lo8(4)
 746:stk500boot.c  **** 
 3006               		.loc 1 746 0
 3007 0c1a 00C0      		rjmp .L157
 3008               	.LVL324:
 3009               	.L153:
 703:stk500boot.c  **** 				}
 3010               		.loc 1 703 0
 3011 0c1c A12C      		mov r10,__zero_reg__
 3012 0c1e B12C      		mov r11,__zero_reg__
 749:stk500boot.c  **** 						{
 3013               		.loc 1 749 0
 3014 0c20 9E30      		cpi r25,lo8(14)
 3015 0c22 01F0      		breq .+2
 3016 0c24 00C0      		rjmp .L204
 3017               	.LVL325:
 752:stk500boot.c  **** 							ii				=	0;
 3018               		.loc 1 752 0
 3019 0c26 1927      		eor r17,r25
 3020               	.LVL326:
 753:stk500boot.c  **** 						}
 3021               		.loc 1 753 0
 3022 0c28 212C      		mov r2,__zero_reg__
 3023 0c2a 312C      		mov r3,__zero_reg__
 3024 0c2c 00C0      		rjmp .L270
 3025               	.LVL327:
 3026               	.L211:
 703:stk500boot.c  **** 				}
 3027               		.loc 1 703 0
 3028 0c2e A12C      		mov r10,__zero_reg__
 3029 0c30 B12C      		mov r11,__zero_reg__
 3030               	.LVL328:
 3031               	.L152:
 762:stk500boot.c  **** 						checksum		^=	c;
 3032               		.loc 1 762 0
 3033 0c32 A101      		movw r20,r2
 3034 0c34 4F5F      		subi r20,-1
 3035 0c36 5F4F      		sbci r21,-1
 3036               	.LVL329:
 3037 0c38 E1E0      		ldi r30,lo8(1)
 3038 0c3a F0E0      		ldi r31,0
 3039 0c3c EC0F      		add r30,r28
 3040 0c3e FD1F      		adc r31,r29
 3041 0c40 E20D      		add r30,r2
 3042 0c42 F31D      		adc r31,r3
 3043 0c44 9083      		st Z,r25
 763:stk500boot.c  **** 						if (ii == msgLength )
 3044               		.loc 1 763 0
 3045 0c46 1927      		eor r17,r25
 3046               	.LVL330:
 764:stk500boot.c  **** 						{
 3047               		.loc 1 764 0
 3048 0c48 4217      		cp r20,r18
 3049 0c4a 5307      		cpc r21,r19
 3050 0c4c 01F0      		breq .+2
 3051 0c4e 00C0      		rjmp .L214
 3052 0c50 1901      		movw r2,r18
 766:stk500boot.c  **** 						}
 3053               		.loc 1 766 0
 3054 0c52 86E0      		ldi r24,lo8(6)
 3055               	.LVL331:
 3056 0c54 00C0      		rjmp .L157
 3057               	.LVL332:
 3058               	.L206:
 703:stk500boot.c  **** 				}
 3059               		.loc 1 703 0
 3060 0c56 A12C      		mov r10,__zero_reg__
 3061 0c58 B12C      		mov r11,__zero_reg__
 3062               	.LVL333:
 3063               	.L61:
 707:stk500boot.c  **** 				{
 3064               		.loc 1 707 0
 3065 0c5a 8330      		cpi r24,lo8(3)
 3066 0c5c 01F0      		breq .L147
 3067 0c5e 00F4      		brsh .+2
 3068 0c60 00C0      		rjmp .L296
 3069 0c62 8530      		cpi r24,lo8(5)
 3070 0c64 01F0      		breq .L152
 3071 0c66 00F4      		brsh .+2
 3072 0c68 00C0      		rjmp .L204
 3073 0c6a 8630      		cpi r24,lo8(6)
 3074 0c6c 01F4      		brne .L146
 3075               	.LVL334:
 3076               	.L154:
 771:stk500boot.c  **** 						{
 3077               		.loc 1 771 0
 3078 0c6e 9113      		cpse r25,r17
 3079 0c70 00C0      		rjmp .L204
 3080 0c72 00C0      		rjmp .L215
 3081               	.LVL335:
 3082               	.L295:
 703:stk500boot.c  **** 				}
 3083               		.loc 1 703 0
 3084 0c74 A12C      		mov r10,__zero_reg__
 3085 0c76 B12C      		mov r11,__zero_reg__
 3086               	.LVL336:
 3087               	.L146:
 672:stk500boot.c  **** 			{
 3088               		.loc 1 672 0
 3089 0c78 8730      		cpi r24,lo8(7)
 3090 0c7a 01F0      		breq .+2
 3091 0c7c 00C0      		rjmp .L157
 3092               	.LVL337:
 3093               	.L215:
 3094 0c7e 912C      		mov r9,__zero_reg__
 3095               	.LVL338:
 3096               	.L101:
 787:stk500boot.c  **** 			{
 3097               		.loc 1 787 0
 3098 0c80 2981      		ldd r18,Y+1
 3099 0c82 2331      		cpi r18,lo8(19)
 3100 0c84 01F4      		brne .+2
 3101 0c86 00C0      		rjmp .L159
 3102 0c88 00F4      		brsh .L160
 3103 0c8a 2630      		cpi r18,lo8(6)
 3104 0c8c 01F4      		brne .+2
 3105 0c8e 00C0      		rjmp .L161
 3106 0c90 00F4      		brsh .L162
 3107 0c92 2230      		cpi r18,lo8(2)
 3108 0c94 01F4      		brne .+2
 3109 0c96 00C0      		rjmp .L191
 3110 0c98 2330      		cpi r18,lo8(3)
 3111 0c9a 01F4      		brne .+2
 3112 0c9c 00C0      		rjmp .L164
 3113 0c9e 2130      		cpi r18,lo8(1)
 3114 0ca0 01F0      		breq .+2
 3115 0ca2 00C0      		rjmp .L158
 3116               	.LVL339:
 851:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 3117               		.loc 1 851 0
 3118 0ca4 1A82      		std Y+2,__zero_reg__
 852:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 3119               		.loc 1 852 0
 3120 0ca6 88E0      		ldi r24,lo8(8)
 3121 0ca8 8B83      		std Y+3,r24
 853:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 3122               		.loc 1 853 0
 3123 0caa 81E4      		ldi r24,lo8(65)
 3124 0cac 8C83      		std Y+4,r24
 854:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 3125               		.loc 1 854 0
 3126 0cae 86E5      		ldi r24,lo8(86)
 3127 0cb0 8D83      		std Y+5,r24
 855:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 3128               		.loc 1 855 0
 3129 0cb2 82E5      		ldi r24,lo8(82)
 3130 0cb4 8E83      		std Y+6,r24
 856:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 3131               		.loc 1 856 0
 3132 0cb6 89E4      		ldi r24,lo8(73)
 3133 0cb8 8F83      		std Y+7,r24
 857:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 3134               		.loc 1 857 0
 3135 0cba 83E5      		ldi r24,lo8(83)
 3136 0cbc 8887      		std Y+8,r24
 858:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 3137               		.loc 1 858 0
 3138 0cbe 80E5      		ldi r24,lo8(80)
 3139 0cc0 8987      		std Y+9,r24
 859:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 3140               		.loc 1 859 0
 3141 0cc2 8FE5      		ldi r24,lo8(95)
 3142 0cc4 8A87      		std Y+10,r24
 860:stk500boot.c  **** 					break;
 3143               		.loc 1 860 0
 3144 0cc6 82E3      		ldi r24,lo8(50)
 3145 0cc8 8B87      		std Y+11,r24
 850:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 3146               		.loc 1 850 0
 3147 0cca 0BE0      		ldi r16,lo8(11)
 3148 0ccc 10E0      		ldi r17,0
 861:stk500boot.c  **** 
 3149               		.loc 1 861 0
 3150 0cce 00C0      		rjmp .L178
 3151               	.LVL340:
 3152               	.L162:
 787:stk500boot.c  **** 			{
 3153               		.loc 1 787 0
 3154 0cd0 2131      		cpi r18,lo8(17)
 3155 0cd2 01F4      		brne .+2
 3156 0cd4 00C0      		rjmp .L166
 3157 0cd6 00F0      		brlo .+2
 3158 0cd8 00C0      		rjmp .L167
 3159 0cda 2031      		cpi r18,lo8(16)
 3160 0cdc 01F4      		brne .+2
 3161 0cde 00C0      		rjmp .L191
 3162 0ce0 00C0      		rjmp .L158
 3163               	.L160:
 3164 0ce2 2831      		cpi r18,lo8(24)
 3165 0ce4 01F4      		brne .+2
 3166 0ce6 00C0      		rjmp .L168
 3167 0ce8 00F4      		brsh .L169
 3168 0cea 2531      		cpi r18,lo8(21)
 3169 0cec 01F4      		brne .+2
 3170 0cee 00C0      		rjmp .L159
 3171 0cf0 00F4      		brsh .+2
 3172 0cf2 00C0      		rjmp .L170
 3173 0cf4 2631      		cpi r18,lo8(22)
 3174 0cf6 01F4      		brne .+2
 3175 0cf8 00C0      		rjmp .L170
 3176 0cfa 00C0      		rjmp .L158
 3177               	.L169:
 3178 0cfc 2A31      		cpi r18,lo8(26)
 3179 0cfe 01F4      		brne .+2
 3180 0d00 00C0      		rjmp .L171
 3181 0d02 00F4      		brsh .+2
 3182 0d04 00C0      		rjmp .L172
 3183 0d06 2B31      		cpi r18,lo8(27)
 3184 0d08 01F4      		brne .+2
 3185 0d0a 00C0      		rjmp .L173
 3186 0d0c 2D31      		cpi r18,lo8(29)
 3187 0d0e 01F0      		breq .+2
 3188 0d10 00C0      		rjmp .L158
 3189               	.LVL341:
 3190               	.LBB202:
 795:stk500boot.c  **** 						{
 3191               		.loc 1 795 0
 3192 0d12 9D81      		ldd r25,Y+5
 3193 0d14 9033      		cpi r25,lo8(48)
 3194 0d16 01F4      		brne .L175
 3195               	.LBB203:
 797:stk500boot.c  **** 
 3196               		.loc 1 797 0
 3197 0d18 8F81      		ldd r24,Y+7
 3198               	.LVL342:
 799:stk500boot.c  **** 							{
 3199               		.loc 1 799 0
 3200 0d1a 8823      		tst r24
 3201 0d1c 01F0      		breq .L216
 803:stk500boot.c  **** 							{
 3202               		.loc 1 803 0
 3203 0d1e 8130      		cpi r24,lo8(1)
 3204 0d20 01F0      		breq .L217
 809:stk500boot.c  **** 							}
 3205               		.loc 1 809 0
 3206 0d22 81E0      		ldi r24,lo8(1)
 3207               	.LVL343:
 3208 0d24 00C0      		rjmp .L176
 3209               	.LVL344:
 3210               	.L175:
 3211               	.LBE203:
 812:stk500boot.c  **** 						{
 3212               		.loc 1 812 0
 3213 0d26 892F      		mov r24,r25
 3214 0d28 8075      		andi r24,lo8(80)
 3215 0d2a 01F0      		breq .L219
 819:stk500boot.c  **** 							{
 3216               		.loc 1 819 0
 3217 0d2c 9035      		cpi r25,lo8(80)
 3218 0d2e 01F4      		brne .L177
 3219               	.LBB204:
 821:stk500boot.c  **** 							}
 3220               		.loc 1 821 0
 3221 0d30 89E0      		ldi r24,lo8(9)
 3222 0d32 E0E0      		ldi r30,0
 3223 0d34 F0E0      		ldi r31,0
 3224 0d36 00C0      		rjmp .L275
 3225               	.L177:
 3226               	.LBE204:
 823:stk500boot.c  **** 							{
 3227               		.loc 1 823 0
 3228 0d38 9835      		cpi r25,lo8(88)
 3229 0d3a 01F4      		brne .L219
 3230               	.LBB205:
 825:stk500boot.c  **** 							}
 3231               		.loc 1 825 0
 3232 0d3c E3E0      		ldi r30,lo8(3)
 3233 0d3e F0E0      		ldi r31,0
 3234 0d40 89E0      		ldi r24,lo8(9)
 3235               	.L275:
 3236               	/* #APP */
 3237               	 ;  825 "stk500boot.c" 1
 3238 0d42 8093 5700 		sts 87, r24
 3239 0d46 8491      		lpm r24, Z
 3240               		
 3241               	 ;  0 "" 2
 3242               	.LVL345:
 3243               	/* #NOAPP */
 3244               	.LBE205:
 3245 0d48 00C0      		rjmp .L176
 3246               	.LVL346:
 3247               	.L216:
 3248               	.LBB206:
 801:stk500boot.c  **** 							}
 3249               		.loc 1 801 0
 3250 0d4a 8EE1      		ldi r24,lo8(30)
 3251               	.LVL347:
 3252 0d4c 00C0      		rjmp .L176
 3253               	.LVL348:
 3254               	.L217:
 805:stk500boot.c  **** 							}
 3255               		.loc 1 805 0
 3256 0d4e 88E9      		ldi r24,lo8(-104)
 3257               	.LVL349:
 3258 0d50 00C0      		rjmp .L176
 3259               	.LVL350:
 3260               	.L219:
 3261               	.LBE206:
 834:stk500boot.c  **** 						}
 3262               		.loc 1 834 0
 3263 0d52 80E0      		ldi r24,0
 3264               	.L176:
 3265               	.LVL351:
 839:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3266               		.loc 1 839 0
 3267 0d54 1A82      		std Y+2,__zero_reg__
 840:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3268               		.loc 1 840 0
 3269 0d56 1B82      		std Y+3,__zero_reg__
 841:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3270               		.loc 1 841 0
 3271 0d58 9C83      		std Y+4,r25
 842:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3272               		.loc 1 842 0
 3273 0d5a 1D82      		std Y+5,__zero_reg__
 843:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3274               		.loc 1 843 0
 3275 0d5c 8E83      		std Y+6,r24
 844:stk500boot.c  **** 						}
 3276               		.loc 1 844 0
 3277 0d5e 1F82      		std Y+7,__zero_reg__
 838:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3278               		.loc 1 838 0
 3279 0d60 07E0      		ldi r16,lo8(7)
 3280 0d62 10E0      		ldi r17,0
 3281 0d64 00C0      		rjmp .L178
 3282               	.LVL352:
 3283               	.L164:
 3284 0d66 EA81      		ldd r30,Y+2
 3285 0d68 E059      		subi r30,lo8(-(112))
 3286 0d6a E330      		cpi r30,lo8(3)
 3287 0d6c 00F4      		brsh .L220
 3288 0d6e F0E0      		ldi r31,0
 3289 0d70 E050      		subi r30,lo8(-(CSWTCH.71))
 3290 0d72 F040      		sbci r31,hi8(-(CSWTCH.71))
 3291 0d74 8081      		ld r24,Z
 3292 0d76 00C0      		rjmp .L179
 3293               	.L220:
 3294               	.LBE202:
 3295               	.LBB207:
 867:stk500boot.c  **** 						{
 3296               		.loc 1 867 0
 3297 0d78 80E0      		ldi r24,0
 3298               	.L179:
 3299               	.LVL353:
 889:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3300               		.loc 1 889 0
 3301 0d7a 1A82      		std Y+2,__zero_reg__
 890:stk500boot.c  **** 					}
 3302               		.loc 1 890 0
 3303 0d7c 8B83      		std Y+3,r24
 3304 0d7e 00C0      		rjmp .L278
 3305               	.LVL354:
 3306               	.L166:
 3307               	.LBE207:
 895:stk500boot.c  **** 					//*	fall thru
 3308               		.loc 1 895 0
 3309 0d80 9924      		clr r9
 3310 0d82 9394      		inc r9
 3311               	.LVL355:
 3312 0d84 00C0      		rjmp .L191
 3313               	.LVL356:
 3314               	.L173:
 3315               	.LBB208:
 906:stk500boot.c  **** 						unsigned char signature;
 3316               		.loc 1 906 0
 3317 0d86 8D81      		ldd r24,Y+5
 3318               	.LVL357:
 909:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3319               		.loc 1 909 0
 3320 0d88 8823      		tst r24
 3321 0d8a 01F0      		breq .L221
 911:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3322               		.loc 1 911 0
 3323 0d8c 8130      		cpi r24,lo8(1)
 3324 0d8e 01F0      		breq .L222
 914:stk500boot.c  **** 
 3325               		.loc 1 914 0
 3326 0d90 81E0      		ldi r24,lo8(1)
 3327               	.LVL358:
 3328 0d92 00C0      		rjmp .L281
 3329               	.LVL359:
 3330               	.L221:
 910:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3331               		.loc 1 910 0
 3332 0d94 8EE1      		ldi r24,lo8(30)
 3333               	.LVL360:
 3334 0d96 00C0      		rjmp .L281
 3335               	.LVL361:
 3336               	.L222:
 912:stk500boot.c  **** 						else
 3337               		.loc 1 912 0
 3338 0d98 88E9      		ldi r24,lo8(-104)
 3339               	.LVL362:
 3340 0d9a 00C0      		rjmp .L281
 3341               	.LVL363:
 3342               	.L171:
 3343               	.LBE208:
 925:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3344               		.loc 1 925 0
 3345 0d9c 1A82      		std Y+2,__zero_reg__
 3346               	.LBB209:
 926:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3347               		.loc 1 926 0
 3348 0d9e E1E0      		ldi r30,lo8(1)
 3349 0da0 F0E0      		ldi r31,0
 3350 0da2 89E0      		ldi r24,lo8(9)
 3351               	/* #APP */
 3352               	 ;  926 "stk500boot.c" 1
 3353 0da4 8093 5700 		sts 87, r24
 3354 0da8 8491      		lpm r24, Z
 3355               		
 3356               	 ;  0 "" 2
 3357               	/* #NOAPP */
 3358               	.L280:
 3359               	.LVL364:
 3360               	.LBE209:
 3361 0daa 8B83      		std Y+3,r24
 927:stk500boot.c  **** 					break;
 3362               		.loc 1 927 0
 3363 0dac 1C82      		std Y+4,__zero_reg__
 924:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3364               		.loc 1 924 0
 3365 0dae 04E0      		ldi r16,lo8(4)
 3366 0db0 10E0      		ldi r17,0
 928:stk500boot.c  **** 
 3367               		.loc 1 928 0
 3368 0db2 00C0      		rjmp .L178
 3369               	.LVL365:
 3370               	.L168:
 3371               	.LBB210:
 934:stk500boot.c  **** 						{
 3372               		.loc 1 934 0
 3373 0db4 8B81      		ldd r24,Y+3
 3374 0db6 8035      		cpi r24,lo8(80)
 3375 0db8 01F4      		brne .L181
 936:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3376               		.loc 1 936 0
 3377 0dba 8C81      		ldd r24,Y+4
 3378 0dbc 8830      		cpi r24,lo8(8)
 3379 0dbe 01F4      		brne .L182
 3380               	.LBB211:
 937:stk500boot.c  **** 							else
 3381               		.loc 1 937 0
 3382 0dc0 E2E0      		ldi r30,lo8(2)
 3383 0dc2 F0E0      		ldi r31,0
 3384 0dc4 00C0      		rjmp .L276
 3385               	.L182:
 3386               	.LBE211:
 3387               	.LBB212:
 939:stk500boot.c  **** 						}
 3388               		.loc 1 939 0
 3389 0dc6 89E0      		ldi r24,lo8(9)
 3390 0dc8 E0E0      		ldi r30,0
 3391 0dca F0E0      		ldi r31,0
 3392 0dcc 00C0      		rjmp .L277
 3393               	.L181:
 3394               	.LBE212:
 3395               	.LBB213:
 943:stk500boot.c  **** 						}
 3396               		.loc 1 943 0
 3397 0dce E3E0      		ldi r30,lo8(3)
 3398 0dd0 F0E0      		ldi r31,0
 3399               	.L276:
 3400 0dd2 89E0      		ldi r24,lo8(9)
 3401               	.L277:
 3402               	/* #APP */
 3403               	 ;  943 "stk500boot.c" 1
 3404 0dd4 8093 5700 		sts 87, r24
 3405 0dd8 8491      		lpm r24, Z
 3406               		
 3407               	 ;  0 "" 2
 3408               	.LVL366:
 3409               	/* #NOAPP */
 3410               	.L281:
 3411               	.LBE213:
 946:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3412               		.loc 1 946 0
 3413 0dda 1A82      		std Y+2,__zero_reg__
 3414 0ddc 00C0      		rjmp .L280
 3415               	.LVL367:
 3416               	.L172:
 3417               	.LBE210:
 3418               	.LBB214:
 957:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3419               		.loc 1 957 0
 3420 0dde 8D81      		ldd r24,Y+5
 3421               	.LVL368:
 3422               	.LBB215:
 958:stk500boot.c  **** 						boot_spm_busy_wait();
 3423               		.loc 1 958 0
 3424 0de0 836C      		ori r24,lo8(-61)
 3425               	.LVL369:
 3426 0de2 99E0      		ldi r25,lo8(9)
 3427               	/* #APP */
 3428               	 ;  958 "stk500boot.c" 1
 3429 0de4 E1E0      		ldi r30, 1
 3430 0de6 F0E0      		ldi r31, 0
 3431 0de8 082E      		mov r0, r24
 3432 0dea 9093 5700 		sts 87, r25
 3433 0dee E895      		spm
 3434               		
 3435               	 ;  0 "" 2
 3436               	/* #NOAPP */
 3437               	.L184:
 3438               	.LBE215:
 959:stk500boot.c  **** 
 3439               		.loc 1 959 0 discriminator 1
 3440 0df0 07B6      		in __tmp_reg__,0x37
 3441 0df2 00FC      		sbrc __tmp_reg__,0
 3442 0df4 00C0      		rjmp .L184
 3443               	.LVL370:
 962:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3444               		.loc 1 962 0
 3445 0df6 1A82      		std Y+2,__zero_reg__
 963:stk500boot.c  **** 					}
 3446               		.loc 1 963 0
 3447 0df8 1B82      		std Y+3,__zero_reg__
 3448               	.LVL371:
 3449               	.L278:
 961:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3450               		.loc 1 961 0
 3451 0dfa 03E0      		ldi r16,lo8(3)
 3452 0dfc 10E0      		ldi r17,0
 3453               	.LBE214:
 965:stk500boot.c  **** 	#endif
 3454               		.loc 1 965 0
 3455 0dfe 00C0      		rjmp .L178
 3456               	.LVL372:
 3457               	.L167:
 971:stk500boot.c  **** 					break;
 3458               		.loc 1 971 0
 3459 0e00 80EC      		ldi r24,lo8(-64)
 3460 0e02 8A83      		std Y+2,r24
 969:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 3461               		.loc 1 969 0
 3462 0e04 02E0      		ldi r16,lo8(2)
 3463 0e06 10E0      		ldi r17,0
 968:stk500boot.c  **** 					msgLength		=	2;
 3464               		.loc 1 968 0
 3465 0e08 CA5D      		subi r28,lo8(-294)
 3466 0e0a DE4F      		sbci r29,hi8(-294)
 3467 0e0c 1882      		st Y,__zero_reg__
 3468 0e0e 1982      		std Y+1,__zero_reg__
 3469 0e10 1A82      		std Y+2,__zero_reg__
 3470 0e12 1B82      		std Y+3,__zero_reg__
 3471 0e14 C652      		subi r28,lo8(294)
 3472 0e16 D140      		sbci r29,hi8(294)
 972:stk500boot.c  **** 
 3473               		.loc 1 972 0
 3474 0e18 00C0      		rjmp .L178
 3475               	.LVL373:
 3476               	.L161:
 976:stk500boot.c  **** 	#else
 3477               		.loc 1 976 0
 3478 0e1a 8A81      		ldd r24,Y+2
 3479 0e1c CB80      		ldd r12,Y+3
 3480               	.LVL374:
 3481 0e1e D12C      		mov r13,__zero_reg__
 3482 0e20 E12C      		mov r14,__zero_reg__
 3483 0e22 F12C      		mov r15,__zero_reg__
 3484 0e24 7601      		movw r14,r12
 3485 0e26 DD24      		clr r13
 3486 0e28 CC24      		clr r12
 3487 0e2a F82A      		or r15,r24
 3488 0e2c 8D81      		ldd r24,Y+5
 3489 0e2e C82A      		or r12,r24
 3490 0e30 8C81      		ldd r24,Y+4
 3491 0e32 D82A      		or r13,r24
 3492 0e34 CC0C      		lsl r12
 3493 0e36 DD1C      		rol r13
 3494 0e38 EE1C      		rol r14
 3495 0e3a FF1C      		rol r15
 3496               	.LVL375:
 3497 0e3c 00C0      		rjmp .L191
 3498               	.LVL376:
 3499               	.L159:
 3500               	.LBB216:
 987:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 3501               		.loc 1 987 0
 3502 0e3e 0A81      		ldd r16,Y+2
 3503 0e40 10E0      		ldi r17,0
 3504 0e42 102F      		mov r17,r16
 3505 0e44 0027      		clr r16
 3506 0e46 8B81      		ldd r24,Y+3
 3507 0e48 082B      		or r16,r24
 3508               	.LVL377:
 994:stk500boot.c  **** 						{
 3509               		.loc 1 994 0
 3510 0e4a 2331      		cpi r18,lo8(19)
 3511 0e4c 01F0      		breq .+2
 3512 0e4e 00C0      		rjmp .L185
 997:stk500boot.c  **** 							{
 3513               		.loc 1 997 0
 3514 0e50 CA5D      		subi r28,lo8(-294)
 3515 0e52 DE4F      		sbci r29,hi8(-294)
 3516 0e54 2881      		ld r18,Y
 3517 0e56 3981      		ldd r19,Y+1
 3518 0e58 4A81      		ldd r20,Y+2
 3519 0e5a 5B81      		ldd r21,Y+3
 3520 0e5c C652      		subi r28,lo8(294)
 3521 0e5e D140      		sbci r29,hi8(294)
 3522 0e60 2115      		cp r18,__zero_reg__
 3523 0e62 80EC      		ldi r24,-64
 3524 0e64 3807      		cpc r19,r24
 3525 0e66 83E0      		ldi r24,3
 3526 0e68 4807      		cpc r20,r24
 3527 0e6a 5105      		cpc r21,__zero_reg__
 3528 0e6c 00F4      		brsh .L186
 999:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3529               		.loc 1 999 0
 3530 0e6e 83E0      		ldi r24,lo8(3)
 3531               	/* #APP */
 3532               	 ;  999 "stk500boot.c" 1
 3533 0e70 F901      		movw r30, r18
 3534 0e72 4093 5B00 		sts  91, r20
 3535 0e76 8093 5700 		sts 87, r24
 3536 0e7a E895      		spm
 3537               		
 3538               	 ;  0 "" 2
 3539               	/* #NOAPP */
 3540               	.L187:
1000:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3541               		.loc 1 1000 0 discriminator 1
 3542 0e7c 07B6      		in __tmp_reg__,0x37
 3543 0e7e 00FC      		sbrc __tmp_reg__,0
 3544 0e80 00C0      		rjmp .L187
1001:stk500boot.c  **** 							}
 3545               		.loc 1 1001 0
 3546 0e82 CA5D      		subi r28,lo8(-294)
 3547 0e84 DE4F      		sbci r29,hi8(-294)
 3548 0e86 2881      		ld r18,Y
 3549 0e88 3981      		ldd r19,Y+1
 3550 0e8a 4A81      		ldd r20,Y+2
 3551 0e8c 5B81      		ldd r21,Y+3
 3552 0e8e C652      		subi r28,lo8(294)
 3553 0e90 D140      		sbci r29,hi8(294)
 3554 0e92 3F5F      		subi r19,-1
 3555 0e94 4F4F      		sbci r20,-1
 3556 0e96 5F4F      		sbci r21,-1
 3557 0e98 CA5D      		subi r28,lo8(-294)
 3558 0e9a DE4F      		sbci r29,hi8(-294)
 3559 0e9c 2883      		st Y,r18
 3560 0e9e 3983      		std Y+1,r19
 3561 0ea0 4A83      		std Y+2,r20
 3562 0ea2 5B83      		std Y+3,r21
 3563 0ea4 C652      		subi r28,lo8(294)
 3564 0ea6 D140      		sbci r29,hi8(294)
 3565               	.LVL378:
 3566               	.L186:
 3567 0ea8 8B85      		ldd r24,Y+11
 3568               	.LBE216:
 3569               	.LBB218:
 914:stk500boot.c  **** 
 3570               		.loc 1 914 0 discriminator 1
 3571 0eaa B701      		movw r22,r14
 3572 0eac A601      		movw r20,r12
 3573 0eae DE01      		movw r26,r28
 3574 0eb0 1B96      		adiw r26,11
 3575               	.LBE218:
 3576               	.LBB219:
1010:stk500boot.c  **** 
 3577               		.loc 1 1010 0 discriminator 1
 3578 0eb2 21E0      		ldi r18,lo8(1)
 3579               	.LVL379:
 3580               	.L189:
 3581 0eb4 1296      		adiw r26,2
 3582               	.LVL380:
 3583 0eb6 FD01      		movw r30,r26
 3584 0eb8 3197      		sbiw r30,1
 3585               	.LVL381:
1009:stk500boot.c  **** 								boot_page_fill(address,data);
 3586               		.loc 1 1009 0 discriminator 1
 3587 0eba 3081      		ld r19,Z
 3588 0ebc 90E0      		ldi r25,0
 3589 0ebe 932B      		or r25,r19
1010:stk500boot.c  **** 
 3590               		.loc 1 1010 0 discriminator 1
 3591               	/* #APP */
 3592               	 ;  1010 "stk500boot.c" 1
 3593 0ec0 0C01      		movw  r0, r24
 3594 0ec2 FA01      		movw r30, r20
 3595 0ec4 6093 5B00 		sts 91, r22
 3596 0ec8 2093 5700 		sts 87, r18
 3597 0ecc E895      		spm
 3598 0ece 1124      		clr  r1
 3599               		
 3600               	 ;  0 "" 2
 3601               	.LVL382:
1012:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3602               		.loc 1 1012 0 discriminator 1
 3603               	/* #NOAPP */
 3604 0ed0 4E5F      		subi r20,-2
 3605 0ed2 5F4F      		sbci r21,-1
 3606 0ed4 6F4F      		sbci r22,-1
 3607 0ed6 7F4F      		sbci r23,-1
 3608               	.LVL383:
1013:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3609               		.loc 1 1013 0 discriminator 1
 3610 0ed8 0250      		subi r16,2
 3611 0eda 1109      		sbc r17,__zero_reg__
 3612               	.LVL384:
1014:stk500boot.c  **** 
 3613               		.loc 1 1014 0 discriminator 1
 3614 0edc 01F0      		breq .L188
1007:stk500boot.c  **** 
 3615               		.loc 1 1007 0
 3616 0ede 8C91      		ld r24,X
 3617               	.LVL385:
 3618 0ee0 00C0      		rjmp .L189
 3619               	.LVL386:
 3620               	.L188:
1016:stk500boot.c  **** 							boot_spm_busy_wait();
 3621               		.loc 1 1016 0
 3622 0ee2 85E0      		ldi r24,lo8(5)
 3623               	.LVL387:
 3624               	/* #APP */
 3625               	 ;  1016 "stk500boot.c" 1
 3626 0ee4 F601      		movw r30, r12
 3627 0ee6 E092 5B00 		sts 91, r14
 3628 0eea 8093 5700 		sts 87, r24
 3629 0eee E895      		spm
 3630               		
 3631               	 ;  0 "" 2
 3632               	/* #NOAPP */
 3633               	.L190:
1017:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3634               		.loc 1 1017 0 discriminator 1
 3635 0ef0 07B6      		in __tmp_reg__,0x37
 3636 0ef2 00FC      		sbrc __tmp_reg__,0
 3637 0ef4 00C0      		rjmp .L190
1018:stk500boot.c  **** 						}
 3638               		.loc 1 1018 0
 3639 0ef6 81E1      		ldi r24,lo8(17)
 3640               	/* #APP */
 3641               	 ;  1018 "stk500boot.c" 1
 3642 0ef8 8093 5700 		sts 87, r24
 3643 0efc E895      		spm
 3644               		
 3645               	 ;  0 "" 2
1012:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3646               		.loc 1 1012 0
 3647               	/* #NOAPP */
 3648 0efe 6A01      		movw r12,r20
 3649 0f00 7B01      		movw r14,r22
 3650               	.LVL388:
 3651 0f02 00C0      		rjmp .L191
 3652               	.LVL389:
 3653               	.L185:
 3654               	.LBB217:
1023:stk500boot.c  **** 							/* write EEPROM */
 3655               		.loc 1 1023 0
 3656 0f04 A701      		movw r20,r14
 3657 0f06 9601      		movw r18,r12
 3658 0f08 5695      		lsr r21
 3659 0f0a 4795      		ror r20
 3660 0f0c 3795      		ror r19
 3661 0f0e 2795      		ror r18
 3662 0f10 CE5D      		subi r28,lo8(-290)
 3663 0f12 DE4F      		sbci r29,hi8(-290)
 3664 0f14 2883      		st Y,r18
 3665 0f16 3983      		std Y+1,r19
 3666 0f18 4A83      		std Y+2,r20
 3667 0f1a 5B83      		std Y+3,r21
 3668 0f1c C252      		subi r28,lo8(290)
 3669 0f1e D140      		sbci r29,hi8(290)
 3670               	.LVL390:
 3671 0f20 3E01      		movw r6,r28
 3672 0f22 3BE0      		ldi r19,11
 3673 0f24 630E      		add r6,r19
 3674 0f26 711C      		adc r7,__zero_reg__
1025:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3675               		.loc 1 1025 0
 3676 0f28 412C      		mov r4,__zero_reg__
 3677 0f2a 512C      		mov r5,__zero_reg__
 3678               	.LVL391:
 3679               	.L192:
 3680 0f2c 4016      		cp r4,r16
 3681 0f2e 5106      		cpc r5,r17
 3682 0f30 01F0      		breq .L297
1026:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 3683               		.loc 1 1026 0
 3684 0f32 D301      		movw r26,r6
 3685 0f34 6D91      		ld r22,X+
 3686 0f36 3D01      		movw r6,r26
 3687 0f38 CE5D      		subi r28,lo8(-290)
 3688 0f3a DE4F      		sbci r29,hi8(-290)
 3689 0f3c 8881      		ld r24,Y
 3690 0f3e 9981      		ldd r25,Y+1
 3691 0f40 C252      		subi r28,lo8(290)
 3692 0f42 D140      		sbci r29,hi8(290)
 3693 0f44 840D      		add r24,r4
 3694 0f46 951D      		adc r25,r5
 3695               	.LVL392:
 3696 0f48 0E94 0000 		call eeprom_write_byte
 3697               	.LVL393:
 3698 0f4c BFEF      		ldi r27,-1
 3699 0f4e 4B1A      		sub r4,r27
 3700 0f50 5B0A      		sbc r5,r27
 3701               	.LVL394:
 3702 0f52 00C0      		rjmp .L192
 3703               	.L297:
 3704 0f54 612C      		mov r6,__zero_reg__
 3705 0f56 712C      		mov r7,__zero_reg__
 3706 0f58 440C      		lsl r4
 3707 0f5a 551C      		rol r5
 3708 0f5c 661C      		rol r6
 3709 0f5e 771C      		rol r7
 3710               	.LVL395:
 3711 0f60 C40C      		add r12,r4
 3712 0f62 D51C      		adc r13,r5
 3713 0f64 E61C      		adc r14,r6
 3714 0f66 F71C      		adc r15,r7
 3715               	.LVL396:
 3716               	.L191:
 3717               	.LBE217:
1033:stk500boot.c  **** 					}
 3718               		.loc 1 1033 0
 3719 0f68 1A82      		std Y+2,__zero_reg__
 3720 0f6a 00C0      		rjmp .L279
 3721               	.LVL397:
 3722               	.L170:
 3723               	.LBE219:
 3724               	.LBB220:
1040:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
 3725               		.loc 1 1040 0
 3726 0f6c 8A81      		ldd r24,Y+2
 3727 0f6e 90E0      		ldi r25,0
 3728 0f70 982F      		mov r25,r24
 3729 0f72 8827      		clr r24
 3730 0f74 3B81      		ldd r19,Y+3
 3731 0f76 832B      		or r24,r19
 3732               	.LVL398:
1042:stk500boot.c  **** 
 3733               		.loc 1 1042 0
 3734 0f78 8C01      		movw r16,r24
 3735 0f7a 0D5F      		subi r16,-3
 3736 0f7c 1F4F      		sbci r17,-1
 3737               	.LVL399:
1044:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3738               		.loc 1 1044 0
 3739 0f7e 1A82      		std Y+2,__zero_reg__
1045:stk500boot.c  **** 						{
 3740               		.loc 1 1045 0
 3741 0f80 2431      		cpi r18,lo8(20)
 3742 0f82 01F4      		brne .L194
1045:stk500boot.c  **** 						{
 3743               		.loc 1 1045 0 is_stmt 0 discriminator 1
 3744 0f84 DE01      		movw r26,r28
 3745 0f86 1396      		adiw r26,3
 3746               	.LVL400:
 3747               	.L195:
 3748               	.LBB221:
 3749               	.LBB222:
1053:stk500boot.c  **** 						#else
 3750               		.loc 1 1053 0 is_stmt 1 discriminator 1
 3751               	/* #APP */
 3752               	 ;  1053 "stk500boot.c" 1
 3753 0f88 EBBE      		out 59, r14
 3754 0f8a F601      		movw r30, r12
 3755 0f8c 2791      		elpm r18, Z+
 3756 0f8e 3691      		elpm r19, Z
 3757               		
 3758               	 ;  0 "" 2
 3759               	.LVL401:
 3760               	/* #NOAPP */
 3761               	.LBE222:
1057:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3762               		.loc 1 1057 0 discriminator 1
 3763 0f90 2C93      		st X,r18
 3764 0f92 1296      		adiw r26,2
 3765               	.LVL402:
 3766 0f94 FD01      		movw r30,r26
 3767 0f96 3197      		sbiw r30,1
1058:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3768               		.loc 1 1058 0 discriminator 1
 3769 0f98 3083      		st Z,r19
1059:stk500boot.c  **** 								size	-=	2;
 3770               		.loc 1 1059 0 discriminator 1
 3771 0f9a E2E0      		ldi r30,2
 3772 0f9c CE0E      		add r12,r30
 3773 0f9e D11C      		adc r13,__zero_reg__
 3774 0fa0 E11C      		adc r14,__zero_reg__
 3775 0fa2 F11C      		adc r15,__zero_reg__
 3776               	.LVL403:
1060:stk500boot.c  **** 							}while (size);
 3777               		.loc 1 1060 0 discriminator 1
 3778 0fa4 0297      		sbiw r24,2
 3779               	.LVL404:
1061:stk500boot.c  **** 						}
 3780               		.loc 1 1061 0 discriminator 1
 3781 0fa6 01F4      		brne .L195
 3782 0fa8 00C0      		rjmp .L196
 3783               	.LVL405:
 3784               	.L194:
 3785 0faa FE01      		movw r30,r28
 3786 0fac 3396      		adiw r30,3
 3787               	.LBE221:
1045:stk500boot.c  **** 						{
 3788               		.loc 1 1045 0
 3789 0fae 9C01      		movw r18,r24
 3790 0fb0 B701      		movw r22,r14
 3791 0fb2 A601      		movw r20,r12
 3792               	.LVL406:
 3793               	.L197:
1067:stk500boot.c  **** 								EEARH	=	((address >> 8));
 3794               		.loc 1 1067 0 discriminator 1
 3795 0fb4 41BD      		out 0x21,r20
1068:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 3796               		.loc 1 1068 0 discriminator 1
 3797 0fb6 452E      		mov r4,r21
 3798 0fb8 562E      		mov r5,r22
 3799 0fba 672E      		mov r6,r23
 3800 0fbc 7724      		clr r7
 3801 0fbe 42BC      		out 0x22,r4
1069:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 3802               		.loc 1 1069 0 discriminator 1
 3803 0fc0 4F5F      		subi r20,-1
 3804 0fc2 5F4F      		sbci r21,-1
 3805 0fc4 6F4F      		sbci r22,-1
 3806 0fc6 7F4F      		sbci r23,-1
 3807               	.LVL407:
1070:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 3808               		.loc 1 1070 0 discriminator 1
 3809 0fc8 F89A      		sbi 0x1f,0
 3810               	.LVL408:
1071:stk500boot.c  **** 								size--;
 3811               		.loc 1 1071 0 discriminator 1
 3812 0fca A0B5      		in r26,0x20
 3813 0fcc A193      		st Z+,r26
 3814               	.LVL409:
1072:stk500boot.c  **** 							} while (size);
 3815               		.loc 1 1072 0 discriminator 1
 3816 0fce 2150      		subi r18,1
 3817 0fd0 3109      		sbc r19,__zero_reg__
 3818               	.LVL410:
1073:stk500boot.c  **** 						}
 3819               		.loc 1 1073 0 discriminator 1
 3820 0fd2 01F4      		brne .L197
 3821 0fd4 AC01      		movw r20,r24
 3822               	.LVL411:
 3823 0fd6 4150      		subi r20,1
 3824 0fd8 5109      		sbc r21,__zero_reg__
 3825 0fda 60E0      		ldi r22,0
 3826 0fdc 70E0      		ldi r23,0
 3827 0fde 4F5F      		subi r20,-1
 3828 0fe0 5F4F      		sbci r21,-1
 3829 0fe2 6F4F      		sbci r22,-1
 3830 0fe4 7F4F      		sbci r23,-1
 3831 0fe6 C40E      		add r12,r20
 3832 0fe8 D51E      		adc r13,r21
 3833 0fea E61E      		adc r14,r22
 3834 0fec F71E      		adc r15,r23
 3835 0fee A3E0      		ldi r26,lo8(3)
 3836 0ff0 B0E0      		ldi r27,0
 3837 0ff2 AC0F      		add r26,r28
 3838 0ff4 BD1F      		adc r27,r29
 3839 0ff6 A80F      		add r26,r24
 3840 0ff8 B91F      		adc r27,r25
 3841               	.LVL412:
 3842               	.L196:
1075:stk500boot.c  **** 					}
 3843               		.loc 1 1075 0
 3844 0ffa 1C92      		st X,__zero_reg__
 3845               	.LBE220:
1077:stk500boot.c  **** 
 3846               		.loc 1 1077 0
 3847 0ffc 00C0      		rjmp .L178
 3848               	.LVL413:
 3849               	.L158:
1081:stk500boot.c  **** 					break;
 3850               		.loc 1 1081 0
 3851 0ffe 80EC      		ldi r24,lo8(-64)
 3852 1000 8A83      		std Y+2,r24
 3853               	.L279:
1080:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3854               		.loc 1 1080 0
 3855 1002 02E0      		ldi r16,lo8(2)
 3856 1004 10E0      		ldi r17,0
 3857               	.LVL414:
 3858               	.L178:
1088:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3859               		.loc 1 1088 0
 3860 1006 8BE1      		ldi r24,lo8(27)
 3861 1008 0E94 0000 		call sendchar
 3862               	.LVL415:
1091:stk500boot.c  **** 			checksum	^=	seqNum;
 3863               		.loc 1 1091 0
 3864 100c C65D      		subi r28,lo8(-298)
 3865 100e DE4F      		sbci r29,hi8(-298)
 3866 1010 8881      		ld r24,Y
 3867 1012 CA52      		subi r28,lo8(298)
 3868 1014 D140      		sbci r29,hi8(298)
 3869 1016 0E94 0000 		call sendchar
 3870               	.LVL416:
1095:stk500boot.c  **** 			checksum	^=	c;
 3871               		.loc 1 1095 0
 3872 101a 812F      		mov r24,r17
 3873 101c 0E94 0000 		call sendchar
 3874               	.LVL417:
1099:stk500boot.c  **** 			checksum ^= c;
 3875               		.loc 1 1099 0
 3876 1020 802F      		mov r24,r16
 3877 1022 0E94 0000 		call sendchar
 3878               	.LVL418:
 3879 1026 85E1      		ldi r24,lo8(21)
 3880 1028 C65D      		subi r28,lo8(-298)
 3881 102a DE4F      		sbci r29,hi8(-298)
 3882 102c 8880      		ld r8,Y
 3883 102e CA52      		subi r28,lo8(298)
 3884 1030 D140      		sbci r29,hi8(298)
 3885 1032 8826      		eor r8,r24
 3886 1034 8026      		eor r8,r16
 3887               	.LVL419:
1102:stk500boot.c  **** 			checksum ^= TOKEN;
 3888               		.loc 1 1102 0
 3889 1036 8EE0      		ldi r24,lo8(14)
 3890 1038 0E94 0000 		call sendchar
 3891               	.LVL420:
1103:stk500boot.c  **** 
 3892               		.loc 1 1103 0
 3893 103c 8126      		eor r8,r17
 3894               	.LVL421:
 3895 103e 9E01      		movw r18,r28
 3896 1040 2F5F      		subi r18,-1
 3897 1042 3F4F      		sbci r19,-1
 3898 1044 3901      		movw r6,r18
 3899 1046 020F      		add r16,r18
 3900 1048 131F      		adc r17,r19
 3901               	.LVL422:
 3902               	.L198:
1106:stk500boot.c  **** 			{
 3903               		.loc 1 1106 0
 3904 104a 6016      		cp r6,r16
 3905 104c 7106      		cpc r7,r17
 3906 104e 01F0      		breq .L298
 3907               	.LVL423:
1108:stk500boot.c  **** 				sendchar(c);
 3908               		.loc 1 1108 0
 3909 1050 D301      		movw r26,r6
 3910 1052 5D90      		ld r5,X+
 3911               	.LVL424:
 3912 1054 3D01      		movw r6,r26
 3913               	.LVL425:
1109:stk500boot.c  **** 				checksum ^=c;
 3914               		.loc 1 1109 0
 3915 1056 852D      		mov r24,r5
 3916 1058 0E94 0000 		call sendchar
 3917               	.LVL426:
1110:stk500boot.c  **** 				msgLength--;
 3918               		.loc 1 1110 0
 3919 105c 8524      		eor r8,r5
 3920               	.LVL427:
 3921 105e 00C0      		rjmp .L198
 3922               	.LVL428:
 3923               	.L298:
 3924 1060 182D      		mov r17,r8
1113:stk500boot.c  **** 			seqNum++;
 3925               		.loc 1 1113 0
 3926 1062 882D      		mov r24,r8
 3927 1064 0E94 0000 		call sendchar
 3928               	.LVL429:
1114:stk500boot.c  **** 	
 3929               		.loc 1 1114 0
 3930 1068 C65D      		subi r28,lo8(-298)
 3931 106a DE4F      		sbci r29,hi8(-298)
 3932 106c 2881      		ld r18,Y
 3933 106e CA52      		subi r28,lo8(298)
 3934 1070 D140      		sbci r29,hi8(298)
 3935 1072 2F5F      		subi r18,lo8(-(1))
 3936 1074 C65D      		subi r28,lo8(-298)
 3937 1076 DE4F      		sbci r29,hi8(-298)
 3938 1078 2883      		st Y,r18
 3939 107a CA52      		subi r28,lo8(298)
 3940 107c D140      		sbci r29,hi8(298)
 3941               	.LVL430:
1118:stk500boot.c  **** 		#endif
 3942               		.loc 1 1118 0
 3943 107e 85B1      		in r24,0x5
 3944 1080 8058      		subi r24,lo8(-(-128))
 3945 1082 85B9      		out 0x5,r24
 3946               	.LVL431:
 3947 1084 40E0      		ldi r20,0
 3948 1086 50E0      		ldi r21,0
 666:stk500boot.c  **** 		{
 3949               		.loc 1 666 0
 3950 1088 9920      		tst r9
 3951 108a 01F4      		brne .+4
 3952 108c 0C94 0000 		jmp .L53
 3953               	.LVL432:
 3954               	.L54:
1153:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3955               		.loc 1 1153 0
 3956 1090 2798      		cbi 0x4,7
1154:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3957               		.loc 1 1154 0
 3958 1092 2F98      		cbi 0x5,7
1156:stk500boot.c  **** #endif
 3959               		.loc 1 1156 0
 3960 1094 84E6      		ldi r24,lo8(100)
 3961 1096 90E0      		ldi r25,0
 3962 1098 0E94 0000 		call delay_ms
 3963               	.LVL433:
1160:stk500boot.c  **** 
 3964               		.loc 1 1160 0
 3965               	/* #APP */
 3966               	 ;  1160 "stk500boot.c" 1
 3967 109c 0000      		nop
 3968               	 ;  0 "" 2
1166:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3969               		.loc 1 1166 0
 3970               	/* #NOAPP */
 3971 109e 8091 C000 		lds r24,192
 3972 10a2 8D7F      		andi r24,lo8(-3)
 3973 10a4 8093 C000 		sts 192,r24
1167:stk500boot.c  **** 
 3974               		.loc 1 1167 0
 3975 10a8 81E1      		ldi r24,lo8(17)
 3976               	/* #APP */
 3977               	 ;  1167 "stk500boot.c" 1
 3978 10aa 8093 5700 		sts 87, r24
 3979 10ae E895      		spm
 3980               		
 3981               	 ;  0 "" 2
1170:stk500boot.c  **** 			"clr	r30		\n\t"
 3982               		.loc 1 1170 0
 3983               	 ;  1170 "stk500boot.c" 1
 3984 10b0 EE27      		clr	r30		
 3985 10b2 FF27      		clr	r31		
 3986 10b4 0994      		ijmp	
 3987               		
 3988               	 ;  0 "" 2
 3989               	/* #NOAPP */
 3990               	.L201:
1185:stk500boot.c  **** }
 3991               		.loc 1 1185 0 discriminator 1
 3992 10b6 00C0      		rjmp .L201
 3993               	.LVL434:
 3994               	.L155:
 713:stk500boot.c  **** 						}
 3995               		.loc 1 713 0
 3996 10b8 1BE1      		ldi r17,lo8(27)
 3997               	.LVL435:
 712:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 3998               		.loc 1 712 0
 3999 10ba 81E0      		ldi r24,lo8(1)
 4000               	.LVL436:
 4001 10bc 00C0      		rjmp .L157
 4002               	.LVL437:
 4003               	.L214:
 4004 10be 1A01      		movw r2,r20
 4005               	.LVL438:
 4006               	.L270:
 4007 10c0 85E0      		ldi r24,lo8(5)
 4008               	.LVL439:
 4009 10c2 00C0      		rjmp .L157
 4010               	.LVL440:
 4011               	.L296:
 707:stk500boot.c  **** 				{
 4012               		.loc 1 707 0
 4013 10c4 8130      		cpi r24,lo8(1)
 4014 10c6 01F4      		brne .+2
 4015 10c8 00C0      		rjmp .L149
 4016 10ca 00F4      		brsh .+2
 4017 10cc 00C0      		rjmp .L157
 4018 10ce 00C0      		rjmp .L150
 4019               	.LVL441:
 4020               	.L204:
 757:stk500boot.c  **** 						}
 4021               		.loc 1 757 0
 4022 10d0 80E0      		ldi r24,0
 4023               	.LVL442:
 4024 10d2 00C0      		rjmp .L157
 4025               		.cfi_endproc
 4026               	.LFE17:
 4028               		.section	.rodata
 4031               	CSWTCH.71:
 4032 0000 0F        		.byte	15
 4033 0001 02        		.byte	2
 4034 0002 0A        		.byte	10
 4035               	.global	gTextMsg_END
 4036               		.section	.progmem.data,"a",@progbits
 4039               	gTextMsg_END:
 4040 0000 2A00      		.string	"*"
 4041               	.global	gTextMsg_HELP_MSG_Y
 4044               	gTextMsg_HELP_MSG_Y:
 4045 0002 593D 506F 		.string	"Y=Port blink"
 4045      7274 2062 
 4045      6C69 6E6B 
 4045      00
 4046               	.global	gTextMsg_HELP_MSG_V
 4049               	gTextMsg_HELP_MSG_V:
 4050 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4050      6F77 2069 
 4050      6E74 6572 
 4050      7275 7074 
 4050      2056 6563 
 4051               	.global	gTextMsg_HELP_MSG_R
 4054               	gTextMsg_HELP_MSG_R:
 4055 0028 523D 4475 		.string	"R=Dump RAM"
 4055      6D70 2052 
 4055      414D 00
 4056               	.global	gTextMsg_HELP_MSG_Q
 4059               	gTextMsg_HELP_MSG_Q:
 4060 0033 513D 5175 		.string	"Q=Quit"
 4060      6974 00
 4061               	.global	gTextMsg_HELP_MSG_L
 4064               	gTextMsg_HELP_MSG_L:
 4065 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4065      7374 2049 
 4065      2F4F 2050 
 4065      6F72 7473 
 4065      00
 4066               	.global	gTextMsg_HELP_MSG_H
 4069               	gTextMsg_HELP_MSG_H:
 4070 004b 483D 4865 		.string	"H=Help"
 4070      6C70 00
 4071               	.global	gTextMsg_HELP_MSG_F
 4074               	gTextMsg_HELP_MSG_F:
 4075 0052 463D 4475 		.string	"F=Dump FLASH"
 4075      6D70 2046 
 4075      4C41 5348 
 4075      00
 4076               	.global	gTextMsg_HELP_MSG_E
 4079               	gTextMsg_HELP_MSG_E:
 4080 005f 453D 4475 		.string	"E=Dump EEPROM"
 4080      6D70 2045 
 4080      4550 524F 
 4080      4D00 
 4081               	.global	gTextMsg_HELP_MSG_B
 4084               	gTextMsg_HELP_MSG_B:
 4085 006d 423D 426C 		.string	"B=Blink LED"
 4085      696E 6B20 
 4085      4C45 4400 
 4086               	.global	gTextMsg_HELP_MSG_AT
 4089               	gTextMsg_HELP_MSG_AT:
 4090 0079 403D 4545 		.string	"@=EEPROM test"
 4090      5052 4F4D 
 4090      2074 6573 
 4090      7400 
 4091               	.global	gTextMsg_HELP_MSG_QM
 4094               	gTextMsg_HELP_MSG_QM:
 4095 0087 3F3D 4350 		.string	"?=CPU stats"
 4095      5520 7374 
 4095      6174 7300 
 4096               	.global	gTextMsg_HELP_MSG_0
 4099               	gTextMsg_HELP_MSG_0:
 4100 0093 303D 5A65 		.string	"0=Zero addr"
 4100      726F 2061 
 4100      6464 7200 
 4101               	.global	gTextMsg_PORT
 4104               	gTextMsg_PORT:
 4105 009f 504F 5254 		.string	"PORT"
 4105      00
 4106               	.global	gTextMsg_EEPROMerrorCnt
 4109               	gTextMsg_EEPROMerrorCnt:
 4110 00a4 4545 2065 		.string	"EE err cnt="
 4110      7272 2063 
 4110      6E74 3D00 
 4111               	.global	gTextMsg_ReadingEEprom
 4114               	gTextMsg_ReadingEEprom:
 4115 00b0 5265 6164 		.string	"Reading EE"
 4115      696E 6720 
 4115      4545 00
 4116               	.global	gTextMsg_WriteToEEprom
 4119               	gTextMsg_WriteToEEprom:
 4120 00bb 5772 6974 		.string	"Writting EE"
 4120      7469 6E67 
 4120      2045 4500 
 4121               	.global	gTextMsg_SPACE
 4124               	gTextMsg_SPACE:
 4125 00c7 2000      		.string	" "
 4126               	.global	gTextMsg_MustBeLetter
 4129               	gTextMsg_MustBeLetter:
 4130 00c9 4D75 7374 		.string	"Must be a letter"
 4130      2062 6520 
 4130      6120 6C65 
 4130      7474 6572 
 4130      00
 4131               	.global	gTextMsg_PortNotSupported
 4134               	gTextMsg_PortNotSupported:
 4135 00da 506F 7274 		.string	"Port not supported"
 4135      206E 6F74 
 4135      2073 7570 
 4135      706F 7274 
 4135      6564 00
 4136               	.global	gTextMsg_WHAT_PORT
 4139               	gTextMsg_WHAT_PORT:
 4140 00ed 5768 6174 		.string	"What port:"
 4140      2070 6F72 
 4140      743A 00
 4141               	.global	gTextMsg_jmp
 4144               	gTextMsg_jmp:
 4145 00f8 6A6D 7020 		.string	"jmp "
 4145      00
 4146               	.global	gTextMsg_rjmp
 4149               	gTextMsg_rjmp:
 4150 00fd 726A 6D70 		.string	"rjmp  "
 4150      2020 00
 4151               	.global	gTextMsg_noVector
 4154               	gTextMsg_noVector:
 4155 0104 6E6F 2076 		.string	"no vector"
 4155      6563 746F 
 4155      7200 
 4156               	.global	gTextMsg_VECTOR_HEADER
 4159               	gTextMsg_VECTOR_HEADER:
 4160 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4160      2041 4444 
 4160      5220 2020 
 4160      6F70 2063 
 4160      6F64 6520 
 4161               	.global	gTextMsg_GCC_VERSION_STR
 4164               	gTextMsg_GCC_VERSION_STR:
 4165 0143 342E 392E 		.string	"4.9.2"
 4165      3200 
 4166               	.global	gTextMsg_AVR_LIBC_VER_STR
 4169               	gTextMsg_AVR_LIBC_VER_STR:
 4170 0149 312E 382E 		.string	"1.8.0svn"
 4170      3073 766E 
 4170      00
 4171               	.global	gTextMsg_GCC_DATE_STR
 4174               	gTextMsg_GCC_DATE_STR:
 4175 0152 4A75 6E20 		.string	"Jun  5 2017"
 4175      2035 2032 
 4175      3031 3700 
 4176               	.global	gTextMsg_FUSE_BYTE_LOCK
 4179               	gTextMsg_FUSE_BYTE_LOCK:
 4180 015e 4C6F 636B 		.string	"Lock fuse   = "
 4180      2066 7573 
 4180      6520 2020 
 4180      3D20 00
 4181               	.global	gTextMsg_FUSE_BYTE_EXT
 4184               	gTextMsg_FUSE_BYTE_EXT:
 4185 016d 4578 7420 		.string	"Ext fuse    = "
 4185      6675 7365 
 4185      2020 2020 
 4185      3D20 00
 4186               	.global	gTextMsg_FUSE_BYTE_HIGH
 4189               	gTextMsg_FUSE_BYTE_HIGH:
 4190 017c 4869 6768 		.string	"High fuse   = "
 4190      2066 7573 
 4190      6520 2020 
 4190      3D20 00
 4191               	.global	gTextMsg_FUSE_BYTE_LOW
 4194               	gTextMsg_FUSE_BYTE_LOW:
 4195 018b 4C6F 7720 		.string	"Low fuse    = "
 4195      6675 7365 
 4195      2020 2020 
 4195      3D20 00
 4196               	.global	gTextMsg_CPU_SIGNATURE
 4199               	gTextMsg_CPU_SIGNATURE:
 4200 019a 4350 5520 		.string	"CPU ID      = "
 4200      4944 2020 
 4200      2020 2020 
 4200      3D20 00
 4201               	.global	gTextMsg_GCC_VERSION
 4204               	gTextMsg_GCC_VERSION:
 4205 01a9 4743 4320 		.string	"GCC Version = "
 4205      5665 7273 
 4205      696F 6E20 
 4205      3D20 00
 4206               	.global	gTextMsg_AVR_LIBC
 4209               	gTextMsg_AVR_LIBC:
 4210 01b8 4156 5220 		.string	"AVR LibC Ver= "
 4210      4C69 6243 
 4210      2056 6572 
 4210      3D20 00
 4211               	.global	gTextMsg_AVR_ARCH
 4214               	gTextMsg_AVR_ARCH:
 4215 01c7 5F5F 4156 		.string	"__AVR_ARCH__= "
 4215      525F 4152 
 4215      4348 5F5F 
 4215      3D20 00
 4216               	.global	gTextMsg_CPU_Type
 4219               	gTextMsg_CPU_Type:
 4220 01d6 4350 5520 		.string	"CPU Type    = "
 4220      5479 7065 
 4220      2020 2020 
 4220      3D20 00
 4221               	.global	gTextMsg_COMPILED_ON
 4224               	gTextMsg_COMPILED_ON:
 4225 01e5 436F 6D70 		.string	"Compiled on = "
 4225      696C 6564 
 4225      206F 6E20 
 4225      3D20 00
 4226               	.global	gTextMsg_HUH
 4229               	gTextMsg_HUH:
 4230 01f4 4875 683F 		.string	"Huh?"
 4230      00
 4231               	.global	gTextMsg_Prompt
 4234               	gTextMsg_Prompt:
 4235 01f9 426F 6F74 		.string	"Bootloader>"
 4235      6C6F 6164 
 4235      6572 3E00 
 4236               	.global	gTextMsg_Explorer
 4239               	gTextMsg_Explorer:
 4240 0205 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4240      696E 6F20 
 4240      6578 706C 
 4240      6F72 6572 
 4240      2073 746B 
 4241               	.global	gTextMsg_CPU_Name
 4244               	gTextMsg_CPU_Name:
 4245 0226 4154 6D65 		.string	"ATmega2560"
 4245      6761 3235 
 4245      3630 00
 4246               		.comm	gEepromIndex,4,1
 4247               		.comm	gFlashIndex,4,1
 4248               		.comm	gRamIndex,4,1
 4249               	.global	app_start
 4250               		.section .bss
 4253               	app_start:
 4254 0000 0000      		.zero	2
 4255               		.text
 4256               	.Letext0:
 4257               		.file 3 "/usr/lib/avr/include/stdint.h"
 4258               		.file 4 "/usr/lib/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccoxLzxi.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccoxLzxi.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccoxLzxi.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccoxLzxi.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccoxLzxi.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccoxLzxi.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccoxLzxi.s:12     .text:0000000000000000 sendchar
     /tmp/ccoxLzxi.s:41     .text.unlikely:0000000000000000 recchar
     /tmp/ccoxLzxi.s:64     .init9:0000000000000000 __jumpMain
     /tmp/ccoxLzxi.s:75     *ABS*:00000000000021ff __stack
     /tmp/ccoxLzxi.s:787    .text.startup:0000000000000000 main
     /tmp/ccoxLzxi.s:114    .text:0000000000000018 delay_ms
     /tmp/ccoxLzxi.s:160    .text:0000000000000036 PrintFromPROGMEM
     /tmp/ccoxLzxi.s:223    .text:000000000000005e PrintNewLine
     /tmp/ccoxLzxi.s:244    .text.unlikely:000000000000000e PrintAvailablePort
     /tmp/ccoxLzxi.s:4104   .progmem.data:000000000000009f gTextMsg_PORT
     /tmp/ccoxLzxi.s:282    .text:000000000000006a PrintFromPROGMEMln
     /tmp/ccoxLzxi.s:302    .text:0000000000000072 PrintString
     /tmp/ccoxLzxi.s:345    .text:000000000000008a PrintHexByte
     /tmp/ccoxLzxi.s:405    .text.unlikely:0000000000000028 DumpHex.constprop.0
     /tmp/ccoxLzxi.s:687    .text:00000000000000b8 PrintDecInt
     /tmp/ccoxLzxi.s:4253   .bss:0000000000000000 app_start
                            *COM*:0000000000000004 gRamIndex
                            *COM*:0000000000000004 gFlashIndex
                            *COM*:0000000000000004 gEepromIndex
     /tmp/ccoxLzxi.s:4239   .progmem.data:0000000000000205 gTextMsg_Explorer
     /tmp/ccoxLzxi.s:4234   .progmem.data:00000000000001f9 gTextMsg_Prompt
     /tmp/ccoxLzxi.s:4094   .progmem.data:0000000000000087 gTextMsg_HELP_MSG_QM
     /tmp/ccoxLzxi.s:4224   .progmem.data:00000000000001e5 gTextMsg_COMPILED_ON
     /tmp/ccoxLzxi.s:4174   .progmem.data:0000000000000152 gTextMsg_GCC_DATE_STR
     /tmp/ccoxLzxi.s:4219   .progmem.data:00000000000001d6 gTextMsg_CPU_Type
     /tmp/ccoxLzxi.s:4244   .progmem.data:0000000000000226 gTextMsg_CPU_Name
     /tmp/ccoxLzxi.s:4214   .progmem.data:00000000000001c7 gTextMsg_AVR_ARCH
     /tmp/ccoxLzxi.s:4204   .progmem.data:00000000000001a9 gTextMsg_GCC_VERSION
     /tmp/ccoxLzxi.s:4164   .progmem.data:0000000000000143 gTextMsg_GCC_VERSION_STR
     /tmp/ccoxLzxi.s:4209   .progmem.data:00000000000001b8 gTextMsg_AVR_LIBC
     /tmp/ccoxLzxi.s:4169   .progmem.data:0000000000000149 gTextMsg_AVR_LIBC_VER_STR
     /tmp/ccoxLzxi.s:4199   .progmem.data:000000000000019a gTextMsg_CPU_SIGNATURE
     /tmp/ccoxLzxi.s:4194   .progmem.data:000000000000018b gTextMsg_FUSE_BYTE_LOW
     /tmp/ccoxLzxi.s:4189   .progmem.data:000000000000017c gTextMsg_FUSE_BYTE_HIGH
     /tmp/ccoxLzxi.s:4184   .progmem.data:000000000000016d gTextMsg_FUSE_BYTE_EXT
     /tmp/ccoxLzxi.s:4179   .progmem.data:000000000000015e gTextMsg_FUSE_BYTE_LOCK
     /tmp/ccoxLzxi.s:4064   .progmem.data:000000000000003a gTextMsg_HELP_MSG_L
     /tmp/ccoxLzxi.s:4054   .progmem.data:0000000000000028 gTextMsg_HELP_MSG_R
     /tmp/ccoxLzxi.s:4099   .progmem.data:0000000000000093 gTextMsg_HELP_MSG_0
     /tmp/ccoxLzxi.s:4089   .progmem.data:0000000000000079 gTextMsg_HELP_MSG_AT
     /tmp/ccoxLzxi.s:4119   .progmem.data:00000000000000bb gTextMsg_WriteToEEprom
     /tmp/ccoxLzxi.s:4114   .progmem.data:00000000000000b0 gTextMsg_ReadingEEprom
     /tmp/ccoxLzxi.s:4124   .progmem.data:00000000000000c7 gTextMsg_SPACE
     /tmp/ccoxLzxi.s:4109   .progmem.data:00000000000000a4 gTextMsg_EEPROMerrorCnt
     /tmp/ccoxLzxi.s:4084   .progmem.data:000000000000006d gTextMsg_HELP_MSG_B
     /tmp/ccoxLzxi.s:4079   .progmem.data:000000000000005f gTextMsg_HELP_MSG_E
     /tmp/ccoxLzxi.s:4074   .progmem.data:0000000000000052 gTextMsg_HELP_MSG_F
     /tmp/ccoxLzxi.s:4069   .progmem.data:000000000000004b gTextMsg_HELP_MSG_H
     /tmp/ccoxLzxi.s:4059   .progmem.data:0000000000000033 gTextMsg_HELP_MSG_Q
     /tmp/ccoxLzxi.s:4049   .progmem.data:000000000000000f gTextMsg_HELP_MSG_V
     /tmp/ccoxLzxi.s:4044   .progmem.data:0000000000000002 gTextMsg_HELP_MSG_Y
     /tmp/ccoxLzxi.s:4159   .progmem.data:000000000000010e gTextMsg_VECTOR_HEADER
     /tmp/ccoxLzxi.s:4154   .progmem.data:0000000000000104 gTextMsg_noVector
     /tmp/ccoxLzxi.s:4149   .progmem.data:00000000000000fd gTextMsg_rjmp
     /tmp/ccoxLzxi.s:4144   .progmem.data:00000000000000f8 gTextMsg_jmp
     /tmp/ccoxLzxi.s:4139   .progmem.data:00000000000000ed gTextMsg_WHAT_PORT
     /tmp/ccoxLzxi.s:4134   .progmem.data:00000000000000da gTextMsg_PortNotSupported
     /tmp/ccoxLzxi.s:4129   .progmem.data:00000000000000c9 gTextMsg_MustBeLetter
     /tmp/ccoxLzxi.s:4229   .progmem.data:00000000000001f4 gTextMsg_HUH
     /tmp/ccoxLzxi.s:4031   .rodata:0000000000000000 CSWTCH.71
     /tmp/ccoxLzxi.s:4039   .progmem.data:0000000000000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_read_byte
__divmodhi4
__udivmodsi4
eeprom_write_byte
__do_copy_data
__do_clear_bss
